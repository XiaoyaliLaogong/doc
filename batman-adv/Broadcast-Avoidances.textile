h1. Broadcast Avoidances

_Status:_ Patches available, not upstream yet

While the concept of rebroadcasting OGMs and broadcast packets is a simple, resilient way to spread information, there are certain scenarios where this approach can be suboptimal, leading to potential congestion.

!rebroadcasts.png!

The main disadvantage of this approach is, that the number of such messages / overhead increases significantly with every extra, neighboring node on an interface. (O(m*n), n = amount of direct neighbors on an interface, m = amount of "originators" [approx.: m = #nodestotal for OGMs, m = #clients for broadcast packets])

There are certain cases where rebroadcasts are unncessary. This page describes mechanisms to detect some common ones to avoid rebroadcasts and by that reducing the OGM and broadcast packet overhead. (O(m*n) => O(m) )

h2. Goal

* Reducing OGM2 and broadcast packet overhead

h2. Scenarios

Here are a few scenarios that the protocol additions described later are supposed to improve:

h3. A) Large, Transitive Link Domains

!wired-aps.png!

_Many mesh nodes wired to one, big switch_

Within buildings it is often easy to deploy at least some cables, or several spots have cabling and patch panels already available. For larger indoor setups it is often advantageous to use at least some cable connections to increase throughput, reliability and available wifi airtime, while keeping wireless mesh routing for difficult spots, mobile nodes or flexibility purposes.

Thanks to the generic design of batman-adv, that is you can configure it on any ethernet interface you like, you can do just that: Run batman-adv on a mix of both wired and wireless interfaces. However, the current rebroadcast approach bears some limitations:

A mesh network of 8 nodes all connected to each other via one 8 port switch would create 16 times the OGM overhead compared to just two nodes. For 24 nodes, this factor increases from 16 to 144 - thanks to rebroadcasting.

However, in this scenario, actually no rebroadcast would be necessary: On a switch a broadcast always reliably arrives on all attached devices. All devices connected "see" each other on their network interface directly, usually with the same full-duplex link speed even.

h3. B) Gathering of Mobile Nodes

!mobile-clusters.png!
_Two mobile nodes clustering around a broadcast transmitter_

In scenarios involving personal mobile nodes and human interaction, it can happen that a number of nodes gather temporarily. As described in scenario A), depending on the number of nodes gathering, this can significantly increase protocol overhead and by that reduce precious wifi airtime.

Nodes close to each other involving similar wireless hardware usually do not provide any better routing options. Therefore it might be unnecessary or even undesirable to have nodes in close proximity to the original sender to rebroadcast OGMs and broadcast packets. This is especially true when taking the half-duplex nature of wireless interfaces running on the same frequency into account, too.

h3. C) Point-to-point and Point-to-Multi-Point Links

!ptp-adsl.png!

_A peer-to-peer tunnel over an asymmetric DSL link_

Some wireless community mesh networks try to interconnect their wireless mesh clouds over common DSL connections. For that they provide tunnel servers relaying the traffic.

Unfortunately, ADSL usually provides limited upstream bandwidth. And for larger mesh communities, the protocol overhead can be quite significant.

Rebroadcasting the large amount of protocol messages coming from the tunnel server on the tunnel client side can lead to a congested ADSL upload.

h2. Simple Broadcast Avoidances

When a node sees just one or no neighbor on a specific interface, then the following, simple rules can be applied to avoid broadcasts on this interface:

h3. I.I) No Neighbor

!bcast-avoid-no-neighbor.png!

* If an interface has no neighbor, then no broadcast is necessary.

For instance, if a mesh node has both a 2.4 and 5GHz interface, but all its neighbor nodes only have a 2.4GHz wifi interface available, then no broadcast on 5GHz is necessary, thus saving wifi airtime for any other 5GHz wireless access points in the vicinity.

h3. I.II) Single Neighbor: Is Originator

!bcast-avoid-single-orig.png!

_Three nodes with a single neighbor per interface each_

* If an interface has just one neighbor and it matches the OGM2 or broadcast packets originator address, then no broadcast is necessary.

We can avoid echoing a packet back to the node it originally came from.

h3. I.III) Single Neighbor: Is Previous Sender

!bcast-avoid-single-fwd.png!

_A node avoiding to echo back to its forwarder_

* If an interface has just one neighbor and it matches the originator that forwarded this OGM2 or broadcast packet to us, then no broadcast is necessary.

We can avoid echoing a packet back to the node it was forwarded from.

h2. Broadcast Avoidance: Neighborhood Hash

The following approach is supposed to mainly improve scenario A) (while improving scenario B) in some specific cases).

h3. Concept

* Each node summarizes all neighbors it sees on an interface via one hash.
* The hash, together with the minimum TX throughput value of this neighborhood is then distributed via an ELP TVLV on the according interface.
* Other nodes compare the received neighborhood hash with their own. If it matches and throughput evaluations indicate no potential for better paths, then rebroadcasts of OGM2 or broadcast packets from the according neighbor on this interface are avoided.

h3. Neighborhood Hash TVLV Format

 * Packet type: 0x03 (BATADV_ELP)
 * TVLV type: 0x01 (BATADV_TVLV_NHH)
 * Length: 68 bytes
 * Fixed TVLV fields:
 ** minimum throughput: the worst of all TX throughputs to any neighbor a node sees on the according interface (4 bytes)
 ** maximum throughput: the best of all TX throughputs to any neighbor a node sees on the according interface (4 bytes)
 ** neighorhood hash: a sha512 hash summarizing all neighbors a node sees on the according interface; hash created from neighbor addresses sorted alphabetically, concatenated, binary (64 bytes)

 * definition:
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV 0x03   |    Version    |             Length            | 
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       minimum throughput                      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       maximum throughput                      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       neighborhood hash...                    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       ....................                    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       ...neighborhood hash                    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

h3. Throughput Evaluation

h4. II.I) Broadcast Packets

_Ingress Check:_

<pre>if fwd-penalty(neigh->max_throughput) < neigh->min_throughput:
-> no rebroadcast</pre>

_Egress Check:_

<pre>if fwd-penalty(iface->max_throughput) < neigh->min_throughput:
-> no rebroadcast</pre>

---

If either (or both):

 * The best TX throughput of the neighbor we received the broadcast packet from with our forwarding penalty applied is smaller than the worst TX throughput of this neighbor (_ingress check_).
 * Our best TX throughput with our forwarding penalty applied is smaller than the worst TX throughput of the neighbor we received the broadcast packet from (_egress check_).

Then a rebroadcast can be avoided.

h4. II.II) OGM2 Packets

While for broadcast packets it is desirable to have them travel over the best TX paths, OGMs propagate inversely. That is they travel along the best RX path while establishing the best TX paths to the originator in the process.

_Ingress Check:_

<pre>if fwd-penalty(neigh->throughput) < iface->min_throughput_other:
-> no rebroadcast</pre>

_Egress Check:_

<pre>if fwd-penalty(iface->max_throughput_other) < iface->min_throughput_other:
-> no rebroadcast</pre>

---

If either (or both):

 * The TX throughput to the neighbor we received the OGM2 packet from with our forwarding penalty applied is smaller than the worst TX throughput of all our neighbors (_ingress check_).
 * The best TX throughput of all our neighbors with our forwarding penalty applied is smaller than the worst TX throughput of all our neighbors (_egress check_).

Then a rebroadcast can be avoided.

h2. BATMAN IV vs. BATMAN V

h1. Appendix

h2. Limitations

h2. Future Improvements

h3. Broadcast Avoidance: Neighborhood Table

For smaller neighborhoods an approach with a higher, computational overhead might be feasible: The neighborhood hash rules are very broad, incapable of detecting many common wireless topologies where rebroadcasts could be avoided.

A more detailed knowledge and view of the local neighborhood allows applying stricter rebroadcast avoidance rules.

A more detailed view could be achieved by every neighbor advertising its full TX throughput list to other neighbors on the according interface.

Receiving neighbors would then have a full RX and TX table between neighbors in the direct, one-hop vicinity.

h2. Hash Collision Probability Assessment

The larger a neighborhood grows the more likely it becomes that two distinct neighborhoods result in the same hash - rapidly. This is thanks to the "Birthday Paradox":https://en.wikipedia.org/wiki/Birthday_problem. A proper assessment of the this to happen is therefore needed.

While usually for wireless mesh networks the number of direct neighbors is rather small, usually less than a dozen, there already exist batman-adv mesh networks with a few hundred neighboring nodes on a VPN interface.

Because the hashing function is applied to a sorted concatenation of the neighbor mac addresses, we can calculate with expected number of unique neighborhood constellations on a specific interface in a given time frame. This Wikipedia article gives us a nice overview of the collision probability with a perfect hash of given output size and a given amount of unique inputs: https://en.wikipedia.org/wiki/Birthday_attack

To achieve a collision probability of 10e-18 with a 512 bit hash, we may have 1.6e68 different inputs. 1.6e68 different inputs would be reached if over 500 years a unique neighborhood were formed 1e58 times per second.

h2. Neighborhood Hash - Throughput Rules Evaluation

h3. Basic Concept

Let's start with a simple, three node example:

!rebroadcast-eval1.png!

_Should B rebroadcast?_

Here, A is our initial broadcaster and B the node having to decide whether or not to rebroadcast on the same, incoming interface.

To decide this, we will compare the direct path between A and C vs. the path from A to C via B:

!rebroadcast-eval2.png!

_Is (AB ⊕ BC) a shortcut or a detour?_

With a simple throughput metric the path from A to C via B is a detour exactly when either the connection from A to B or from B to C (or both) is a bottleneck. That is if either AB or BC offers a smaller throughput than AC.

That means B can perform an _ingress check_ (AB < AC?) and an _egress check_ (BC < AC?) individually.

To make sure, that a rebroadcast is unnecessary, B would need to perform such an ingress and egress check for any neighbor Cn (any neighbor other than A):

!rebroadcast-eval3.png!

If B notices that for all these neighbors Cn it is a bottleneck and no improvement then B can safely avoid a rebroadcast.

h3. Simplification

Simple, ey? So we just try all these checks! - Not so fast...

Currently, we have two problems: For one thing, the computational overhead could be significant for neighborhoods of a certain size. For another, B does not even know the throughput from A to B or A to C (or C to A or C to B - we will see later why we might need those). B only knows its own TX throughput towards other neighbors and not the other way around.

Instead of every neighbor node frequently broadcasting a full list of TX values and every neighbor performing all these checks for any neighbor with any neighbor combination, the implemented neighbor hash approach applies a huge simplification needing considerably less computations and information exchange:

Instead of checking all (AB < ACn?) and (BCn < ACn?) combinations, it tries to perform "one check that rules them all" (with the downside of maybe not catching all potential rebroadcast avoidance cases).

h3. Proofs

h4. Proof: Egress TX (bcast)

We want to proof:

 * p(Bmax) < Amin => p(BCn) < ACn

One has:

 * p(x) < x
 * a ≤ b => p(a) ≤ p(b)
 * BCn ≤ Bmax
 * Amin ≤ ACn

<pre>
BCn ≤ Bmax
=> p(BCn) ≤ p(Bmax)

p(Bmax) < Amin
=> (p(BCn) ≤ p(Bmax)) < Amin
=> (p(BCn) ≤ p(Bmax)) < (Amin ≤ ACn)
=> p(BCn) ≤ p(Bmax) < Amin ≤ ACn
=> p(BCn) < ACn
</pre>

h4. Proof: Ingress TX (bcast)

We want to proof:

 * p(Amax) < Amin => p(AB) < ACn for any Cn.

One has:

 * p(x) ≤ x
 * a ≤ b => p(a) ≤ p(b)
 * AB ≤ Amax
 * Amin ≤ ACn

<pre>
AB ≤ Amax
=> p(AB) ≤ p(Amax)

p(Amax) < Amin
=> (p(AB) ≤ p(Amax)) < Amin
=> (p(AB) ≤ p(Amax)) < (Amin ≤ ACn)
=> p(AB) ≤ p(Amax) < Amin ≤ ACn
=> p(AB) < ACn
</pre>

h4. Proof: Ingress RX (OGM2)

We want to proof:

 * AB ≤ MIN<code></code>(Amin, Cn-min) => AB ≤ CnA for any Cn.

One has:

 * Cn-min ≤ CnA

<pre>AB ≤ MIN(Amin, Cn-min)
=> AB ≤ Cn-min
=> AB ≤ (Cn-min ≤ CnA)
=> AB ≤ CnA</pre>

h4. Proof: Egress RX (OGM2)

We want to proof:

 * MAX<code></code>(Amax, Cn-max) ≤ MIN<code></code>(Amin, Cn-min) => AB ≤ CnA for any Cn.

One has:

 * AB ≤ Amax
 * Cn-min ≤ CnA

<pre>MAX(Amax, Cn-max) ≤ MIN(Amin, Cn-min)
=> Amax ≤ Cn-min
=> (AB ≤ Amax) ≤ Cn-min
=> (AB ≤ Amax) ≤ (Cn-min ≤ CnA)
=> AB ≤ CnA