h1. Client announcements

Each mesh protocol offering network access to non-mesh clients needs a 'client announcement' system. The task of such a system is to inform every mesh node in the network of any connected non-mesh client, in order to find the path towards that client from any given point in the mesh. A client has an identifier (usually its IP address for layer 3 routing and MAC address for layer 2 routing) that is flooded through the mesh. As B.A.T.M.A.N.-Advanced is a Layer2 mesh routing protocol clients are represented by their MAC address.

h2. The local translation table

Every client MAC address that is recognized through the mesh interface will be stored in a node local table called "local translation table" which will contain all the clients the node is currently serving. This table is the information a node has to spread among the network in order to make its clients reachable. This is because when a node wants to contact a particular client, thanks to this information, it knows the originator it has to send the data to. 
Each node local table has a particular attribute: the translation table version number (ttvn). The value of this attribute represents the version of the table that is incremented by one each time the local table changes (a client has been added/removed). For optimization reasons all changes which happen within the same OGM interval are aggregated into a single ttvn increment.
Every OGM broadcast contains the current ttvn and a crc16 checksum value of the local table to allow the receiving nodes to quickly decide whether the tables are in sync or not.

h2. The global translation table

Every node in the network has to store all the other node's local tables. To achieve this, another table is needed: the "global translation table". It is a set of entries where each contains the client MAC address and a pointer to the originator that is currently announcing it.

h2. Updating the tables

At boot time, every node will have an empty local table and empty global one. Its ttvn will be initialized to 0. The OGM broadcast represents the local table propagation event. 

As soon as a local event occurred (client added/deleted) the ttvn is incremented by one on the next propagation event (OGM broadcast). In addition, the local changes since the last OGM broadcast are appended to the OGM itself. This mechanism helps to avoid the more expensive table request operation (see below) as any receiving node can retrieve the changes from the OGM to update its global translation table.

The tt change entry format:
* Flags: Indicates whether this client address is to be added or removed.
* Client Address: Address of the concerning client.

<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    Flags      |            Client Address                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                     Client Address            |               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

These changes are also appended to the 2 following OGMs if there were no new changes in the meantime, thereby increasing the chance for neighbor node to receive the changes in the event of packet loss. If a node receives an OGM containing a new ttvn without the changeset (e.g. it missed all 3 OGMs with the changeset or the changeset exceeded the packet size) or the crc16 checksum does not match it can issue a table request. In particular a node can ask for two different information: Either the changeset of the current ttvn or the full local table.

The tt request format:
* Packet type: Initialize this field with the TT_QUERY packet type.
* Version: Set your internal compatibility version.
* Destination Address: Address of the host this packet should be forwarded to.
* TTL: Time-To-Live field decreased by with one with each hop. Packet is to be discarded when counter reaches 0.
* Flags: The flag field is used to distinguish between a TT_REQUEST and a TT_RESPONSE and to inform whether the message is asking for/carrying a full local table or only the changeset of the current ttvn.
* Source Address: Address of the host sending this message.
* TTVN: If the message is of type TT_REQUEST this field specifies the request translation table version number. If it is of type TT_RESPONSE it contains the ttvn of the data in the reply.
* TT Data: If the message is of type TT_REQUEST this field is filled with the crc16 checksum of the specified ttvn. If it is of type TT_RESPONSE this field is set to the number of entries the message is carrying. This information is needed to let the receiver node correctly handle the appended buffer. 

<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Packet Type   |    Version    |     TTL       |    Flags      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                      Destination Address                      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |      Destination Address      |         Source Address        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                      Source Address                           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |     TTVN      |          TT Data              |    . . .      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

The reply to any tt request can either be the changeset of the current ttvn or the full local table. The changeset always is the preferred format to answer the request as it comes with a smaller overhead penalty. In same cases a changeset reply is not possible (e.g. a node just joined the mesh) which makes a full table reply necessary. If the reply contains the changeset of the current ttvn the corresponding change entries (see above) are appended to the reply. If the reply contains the full table the entire list of client addresses is appended to the message using the change entry format containing the MAC addresses and corresponding flags.

h2. Table request forwarding:

To reduce the overhead of the table request operations, each node on the path of a TT_REQUEST message will inspect the contents and decide whether it has the correct information to answer the request directly without forwarding the TT_REQUEST any further. The ttvn and the crc16 checksum contained in the request message provide sufficient means to verify if it matches with the locally available information. If they match the node can directly reply to the request (with the full table of the destination's translation table or the changeset of the last ttvn if possible). If something didn't match, the node will forward the packet to the nexthop in the path to the destination.

h2. Computing the crc16 checksum:

The crc16 checksum field which is sent along with the ttvn field in the OGM is computed for a generic originator O as "the xor of the crc16 values of the MAC addresses in the local translation table entries".

**Pseudocode**:
<pre><code>tt_local_crc(orig_node O) {
res = 0;
for each tt_local_entry:
     res = res XOR crc16(tt_local_entry->addr)
endfor
return res</code></pre>

h2. Improving data routing

The ttvn field has also been added to the unicast packet header. A node sending a packet of this type will set this field to the currently known destination's ttvn. Along the path from the source to the destination, every node will inspect the packet and check whether it knows an higher ttvn for the same destination; if so, the node will look in its global translation table to see which is the current mesh node serving the client which the packet is directed to. At this point the intermediate node will replace the destination and the ttvn values in the unicast packet header and will re-forward the packet to the new destination (possibly the same).

This behavior slightly helps in case of roaming: a client moved from a mesh node to another, but the source node doesn't know this change yet. Data is sent to the old node serving the client, but as soon as the packet reaches an updated node, it will be redirected to the new (possibly correct) destination.

h2. Limitations

* MAC conflict: in case of several nodes announcing the same client MAC address, the global table of each node will be continuously updated leading to a route flip (towards the client) on all nodes.
* Too many local clients: If the number of local clients exceeds the limit of entries that fit into a single packet (1500 bytes) the exceeding clients won't be announced.


h2. Notes

A research project has been done on this topic and it will be linked on this page as soon as it get ready.