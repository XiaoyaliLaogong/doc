h1. Client announcements

Each mesh protocol offering network access to non-mesh clients needs a 'client announcement' system. The task of such a system is to inform every mesh node in the network of any connected non-mesh client, in order to find the path towards that client from any given point in the mesh. A client has an identifier (usually its address: IP address for layer 3 routing and MAC address for layer 2 routing) that is flooded through the mesh. As B.A.T.M.A.N.-Advanced is a Layer2 mesh routing protocol clients are represented by their MAC address.

h2. The local translation table

Every client MAC address that is recognized through the mesh interface will be stored in a node local table called "local translation table" which will contain all the clients the node is currently serving. This table is the information a node has to spread among the network in order to make clients reachable. This is because when a node wants to contact a particular client, thanks to this information, it knows the originator it has to send the data to. 
Each node local table has a particular attribute: the translation table version number (ttvn). The value of this attribute represents the version of the table that is incremented by one each time the local table changes (a client has been added/removed). For optimization reasons all changes which happen within the same OGM interval are aggregated into a single ttvn.
Every OGM broadcast contains the current ttvn and a crc16 checksum value of the local table to allow the receiving nodes to quickly decide whether they tables are in sync or not.

h2. The global translation table

Every node in the network has to store all the other node's local tables. To achieve this, another table is needed: the "global translation table". It is a set of entries where each contains the client MAC address and a pointer to the originator that is currently announcing it.

h2. Updating the tables

At boot time, every node will have an empty local table and empty global one. Its ttvn will be initialized to 0. The OGM broadcast represents the local table propagation event. 

As soon as a local event occurred (client added/deleted) the ttvn is incremented by one on the next propagation event (OGM broadcast). In addition, the local changes since the last OGM broadcast are appended to the OGM itself. This mechanism helps to avoid the more expensive table request operation (see below) as any receiving node can retrieve the changes from the OGM to update its global translation table.

Each change entry is represented by a tt_change structure:
<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    Flags      |            Client...                          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         ...Address            |               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

The flags field indicates the related operation (**add** a client or **delete** a client), while the addr field contains the interested client MAC address.

These changes are also appended to the 2 following OGMs if there were no new changes in the meantime, thereby increasing the chance for neighbor node to receive the changes in the event of packet loss. If a node receives an OGM containing a new ttvn without the changeset (e.g. it missed all 3 OGMs with the changeset or the changeset exceeded the packet size) or the crc16 checksum does not match it can issue a table request. In particular a node can ask for two different information:
- The originator's full local table
- The last set of changes from the current ttvn.

This distinction is done using the TT_FULL_TABLE bit of the bitwise **flag field** in the TT_QUERY packet.

The originator that receives the TT_REQUEST message will reply with a TT_RESPONSE to which the node will append the requested data.

The TT_REQUEST message will contain the following fields:
In particular the TT_REQUEST/TT_REPONSE messages are two subtypes of the TT_QUERY message which has the following format:

<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Packet Type   |    Version    |      Destination...           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         ...Address                            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | TTL           |    Flags      |      Source...                |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         ...Address                            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TTVN        |                  TT_Data                      |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

The flag field is used to distinguish between a TT_REQUEST and a TT_RESPONSE and to inform whether the TT_QUERY message is asking for/carrying a full local table or only the last OGM transtable buffer.

The ttvn field is used to inform about the ttvn is asking for/replying with.
So, in case of OGM buffer request, this value will be set to the ttvn associated to the buffer the node needs.

The tt_data field has different content in case of TT_REQUEST or TT_RESPONSE.
If the message is a TT_REQUEST, this field is set to the tt_crc value (for details about this value, please read the TT consistency section) that the
requesting node received by means of the OGM from the destination (of this TT_REQUEST).
If the message is a TT_RESPONSE then this field is set to the number of entries the message is carrying. This information is needed to let the receiver
node correctly handle the appended buffer. 

In case of unavailability of the last OGM transtable buffer the node will answer with the full table.

h2. Table request forwarding:

To reduce the overhead of the table request operations, each node on the path of a TT_REQUEST message will inspect the contents and decide whether it has the correct information to answer the request directly without forwarding the TT_REQUEST any further. The ttvn and the crc16 checksum contained in the request message provide sufficient means to verify if it matches with the locally available information. If they match the node can directly reply to the request (with the full table of the destination's translation table or the changeset of the last ttvn if possible). If something didn't match, the node will forward the packet to the nexthop in the path to the destination.

h2. Computing the crc16 checksum:

The crc16 checksum field which is sent along with the ttvn field in the OGM is computed for a generic originator O as "the xor of all the crc16 values of each local tt table address entry".

**Pseudocode**:
<pre><code>tt_local_crc(orig_node O) {
res = 0;
for each tt_local_entry:
     res = res XOR crc16(tt_local_entry->addr)
endfor
return res</code></pre>

h2. Improving data routing

The ttvn field has also been added to the unicast packet header. A node sending a packet of this type will set this field to the currently known destination's ttvn. Along the path fro the source to the destination, every node will inspect the packet and check whether it knows an higher ttvn for the same destination; if so, the node will look in its global translation table to see which is the current mesh node serving the client which the packet is directed to. At this point the intermediate node will replace the destination and the ttvn values in the unicast packet header and will re-forward the packet to the new destination (possibly the same).

This behaviour slightly helps in case of roaming: a client moved from a mesh node to another, but the source node doesn't know this change yet. Data is sent to the old node serving the client, but as soon as the packet reaches an updated node, it will be redirected to the new (an possibly correct) destination.

h2. Limitations

- **MAC conflict**: in case of several node announcing the same client MAC address, the global table of each node will be continuously updated leading to a route flip (towards the client) on all nodes

h2. Notes

A research project has been done on this topic and it will be linked on this page as soon as it get ready.