h1. BackwardsCompatibility

Everything on this page is a suggestion and a work in progress therefore open to discussion and change.

h2. Intro

Right now batman does not have any  real backwards compatibility. We could implement real backward compatibility through the use of IEs (information elements) and more specifically TLVs (type/length/value) elements.

First the closest thing I found in wireless information elements is the wifi ones. For everyone who is not aware of the basics, here is a "link":http://etutorials.org/Networking/802.11+security.+wi-fi+protected+access+and+802.11i/Part+II+The+Design+of+Wi-Fi+Security/Chapter+13.+Wi-Fi+LAN+Coordination+ESS+and+IBSS/WPA+RSN+Information+Element/ with a brief and general/abstract description

h2. Main

There are many ways to encode such an element. Each providing different pros/cons and all of which are used in various applications.

# "Ber":http://en.wikipedia.org/wiki/Basic_Encoding_Rules (Basic Encoding Rules):
 and its two subsets
  # "Cer":http://en.wikipedia.org/wiki/Canonical_Encoding_Rules
  # "DER":http://en.wikipedia.org/wiki/Distinguished_Encoding_Rules (Distinguished Encoding Rules)  it is more restrictive than the first one
and 
# "PER":http://en.wikipedia.org/wiki/Packed_Encoding_Rules (Packed Encoding Rules)  defines some more fields
    

They are all part of the "Abstract Notation 1":http://en.wikipedia.org/wiki/ASN.1

Although they are extremely cool, and versatile I think that they might be a bit of an overkill and unencoded tlvs may do just fine.
Explanations:

The true power of BER comes from the fact that it can define the type of the value field and also this format allows a receiver to decode the ASN.1 information from an incomplete stream, without requiring any pre-knowledge of the size, content, or semantic meaning of the data.

Cer/Der are more restrictive and according to wikipedia they are used when there is a reason to restrict your data to only one type (e.g. security)
but in the real world even credit cards use Ber.


For the record there is already an external tlv message parser "Tlve":http://tlve.sourceforge.net/ ("example of ber parsing":http://tlve.sourceforge.net/examples/ber.rc)

h2.  In-Kernel functionality

Most systems use tlvs for a variety of things (from Alsa that uses unencoded tlvs to set the sound levels to the wifi)

There is already functionality for encoding/decoding 
#CIFS http://lxr.linux.no/#linux+v3.3.5/fs/cifs/asn1.c#L2
#nat_snmp_basic http://lxr.linux.no/#linux+v3.3.5/net/ipv4/netfilter/nf_nat_snmp_basic.c#L62


h2.  TLV concept

Since the number of different messages transmitted is relatively low the following struct should be enough to contain the information of each message

struct tlv {
          u8 type;
          u8 length;
          u8 value[255];
  };
/*i'm not yet sure about the u8 in the value field, maybe it should be u32*/

the type should be:

typedef enum {
         A_TLV   = 0x00,
         B_TLV   = 0x01,
         C_TLV   = 0x02,
         D_TLV   = 0x03,
         E_TLV   = 0x04,
         G_TLV   = 0X05, 
         F_TLV   = 0X06,
         .
         .
         .
         .
         X_TLV	 = 0XFF,  
     } bat_tlv;

where each hex code represents the kind of message we are waiting to parse


the whole thing gets serialized and transmited the receiver deserializes
the message and passes it to the appropriate method depending on the type value

(i have to work on the serialization though in the user space its kinda tricky, maybe the kernel has something)

h2. Fields to be tlv-fied

Assuming that the ogm message is described by the struct batman_ogm_packet 

Until now i think that only two fields need their own tlvs

	 flags;   
	 gw_flags;  /* flags related to gateway class */

h2. reasons:
	struct batman_header header;
the header already has version identifiers and packet type identifier so putting it in a tlv is useless overhead

	__be32   seqno; 

just an int(maybe) does not describe anything new(?)

	uint8_t  orig[ETH_ALEN];

as I understand it describes a mac address so it wont cange in the future

	uint8_t  prev_sender[ETH_ALEN];

same as above

	uint8_t  tq;

same as above(?)
	
                uint8_t  tt_num_changes;

just an int no reason to tlv it
	
                    uint8_t  ttvn; /* translation table version number */

it's a version number how can a node not understand a version number?	

                  __be16   tt_crc;

dont understand what this field means (and a quick wiki search returnen no results) decision postponed
