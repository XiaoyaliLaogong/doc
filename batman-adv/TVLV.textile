h1. BackwardsCompatibility

h2. Code

* http://git.open-mesh.org/?p=batman-adv.git;a=shortlog;h=refs/heads/northpole/tvlv-clean

h2. Intro

Right now batman does not have any  real backwards compatibility. The project's goal is to implement  backwards compatibility through the use of IEs (information elements) and more specifically TLVs (type/length/value) elements.

h2.  TVLV concept

At the end of each OGM are appended a set of tvlv (type-version-length-value) containers to announce the support of a feature set or to transfer messages of a feature. The standard TLV concept has been enriched by a version field as it can be safely assumed features evolve over time. Every feature is assigned a unique tvlv type as identifier (see below). 

Batman-adv tvlv definition:

In batman-adv we will be using three kinds of tvlvs

h3. A short tvlv is defined bellow

<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV Type   |    Version    |    Length     |  Value
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

h3. A long one is defined bellow

<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV Type   |    Version    |    Length                 | 
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    Value of length bytes long                                 |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

h3. An empty tvlv  with a length of zero and no value is allowed to simply announce the support of a feature

<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV Type   |    Version    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

+NOTE+
Long tvlvs have a type bigger than 0x81, short tvlvs have a type shorter than 0x80 and zero tvlvs should have the type of the feature they announce support of.

h2. BATMAN TVLV list

h3. Due to the individual requirements of every feature a list of existing feature tvlv follows.

h3. Gateway announcement

 * tvlv type: 0x01
 * function: Each batman-adv gateway server announces it's available internet connection speed, so that batman-adv gateway clients can select their preferable server.
 * purpose: Every node keeps a list of batman-adv gateways in the mesh to later the preferred gateway. 
 * length: 1 byte gateway flags (see batman_ogm_packet->gw_flags)
 * definition:
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV 0x01   |    Version    |    Length     |    GW Flags   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

State: Done.

h3. DAT (Distributed ARP Table)

 * tvlv type: 0x02
 * function: D.A.T. is a DHT based global ARP cache
 * purpose: the DAT component will only query other DAT-enabled nodes
 * length: 0 (This is a boolean telling that this node caches ARP requests / replies for the mesh.)
 * definition:
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV 0x02   |    Version    |    Length     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

h3. Translation table / TT messages

 * tvlv type: 0x81
 * function: Node local clients advertisement mechanism. This particular component needs some parameters that are were carried by the OGM. Now these fields can be encapsulated in the tvlv (see below to understand what fields I'm talking about).
 * purpose: nodes need to exchange TranslationTable state information
 * length: variable (it depends on the number of changes that the tvlv is carrying). Fixed tvlv fields:
 ** batman_ogm_packet->ttvn (1Byte)
 ** batman_ogm_packet->tt_crc (2Bytes)
 * definition:
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV 0x03   |    Version     |    Length                         | 
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |     TTVN         |             TT CRC            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

State: W.I.P.

h3. Bla(bridge loop avoidance)

 * tvlv type: 0x??
 * function: Bridge Loop Avoidance is used to avoid loops between a backbone network (e.g. LAN) and the mesh. More documentation at the wiki at: [[Bridge-loop-avoidance-II]]
 * purpose: TBD - so far, no compatibility has been defined between nodes which support BLA and nodes which don't.
 * length: 0 byte
 * note: needs more discussion whether we really need that.

h3. Vis server

 * tvlv type: 0x??
 * function: The vis server allow to dump a complete network graph of the mesh network. To do this, vis clients send their neighbor and tt data to vis servers. The vis servers then share the collected data between each other.
 * purpose: Clients may send their vis data to the server if the vis TLV is present.
 * length: 0 byte
 * definition:
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV 0x??   |    Version    |    Length     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

h3. Vis information packet (PROPOSAL)

 * tvlv type: 0x??
 * function: The vis server allow to dump a complete network graph of the mesh network. To do this, vis clients send their neighbor and tt data to vis servers. The vis servers then share the collected data between each other.
 * purpose: information packet are sent from clients to servers or from servers to servers to propagate neighbor/client information. The packets are NOT attached to OGMs, but are sent via unicast instead
 * discussion: we may want to move target originator (maybe others?) in general headers so that non-vis-aware nodes can forward the packets.
 * length: variable - 23 byte + #entries * 7 byte
 * definition:
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV 0x??   |    Version    |    Length     |   VIS_TYPE    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Sequence Number                                             |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Vis Originator                                              |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Vis Originator (cont'd)     |    Target Originator          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Target Originator (cont'd)                                  |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Sender Originator                                           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Sender Originator (cont'd)  |    ... (entries) ...          |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>
 * entry definition:
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   SRC MAC                                                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   SRC MAC (cont'd)            |   DST MAC                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   DST MAC (cont'd)                                            |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Quality     |
 +-+-+-+-+-+-+-+-+

</pre>


h3. Catwoman (network coding)

 * tvlv type: to be decided upon merge into the master branch
 * function: Nodes compiled with support for network and has enabled network coding, announces this, so that other nodes do not send coded packets to nodes unable to understand such.
 * purpose: network encoded packets will only sent to nodes that have network coding enabled
 * length: 0 (This is a boolean telling that this node knows how to decode nc-packets.)
 * definition:
<pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   TVLV TBD    |    Version    |    Length     |  
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

h3. Multicast capability (TODO => Simon / Edo)

 * tvlv type: to be decided upon merge into the master branch
 * function: The current (unfinished) implementation optimizes for sparse multicast networks, with groups (much) smaller than half the nodes of the network. It first sends out tracker packets to mark the multicast tree for the following stream.
 * purpose: TBD. We could use a TLV to announce the Multicast MAC addresses we want to listen to (similar to the early TT mechanism).
 * length: TBD
 * note: should not be considered for now, we can pick it up again as soon as it gets some love from a developer.

h2.  Api description
 
Its rather simple to change a feature to use tvlvs. 

h3. Sending

To turn tvlv sending on, thus send a tvlv with every ogm packet all that is needed to be done is add a call to 
<pre>
void batadv_tvlv_register(struct batadv_priv *bat_priv, uint8_t type,
			  uint8_t version, uint16_t length,
			  uint8_t *value);

</pre>

You can call the same function in order to update the value field,

+NOTE+ since there are two types of tvlvs (short and long ones) the convention is that any tvlv with type bigger than 0x80 is a long one and smaller than that a short one, only difference that length will be assigned to a one byte variable for short tvlvs and two byte variable for long ones.

In order to unregister the tvlv thus stop sending it you call

<pre>void batadv_tvlv_unregister(struct batadv_priv *bat_priv, uint8_t type);</pre>

h3. Receiving

In order to pass a tvlv value to the feature specific function an intermediate handler function is needed.
In order to register/unregister the handler function a call to each of the following is necessary.

<pre>void batadv_tvlv_handler_unregister(struct batadv_priv *bat_priv,uint8_t type);

void batadv_tvlv_handler_register(struct batadv_priv *bat_priv,
				  void (*ptr)(struct batadv_priv *bat_priv,
					      struct batadv_orig_node *orig,
					      uint8_t *value,
					      uint8_t version),
				  uint8_t type, uint8_t call_always);

</pre>

+NOTES+ : 
# A handler of type "type" handles a tvlv of type "type".

h3. Call a handler without a received tvlv

There is a special field for the handlers named +call_always+, it enables the handler to be called each time an OGM was received with a value of BATADV_NO_FLAGS  and a 0 as version even if the appropriate tvlv wasn't received.
Its useful for features which used to await a BATADV_NO_FLAGS in the ogm to turn off a feature or unregister something.
If you want the handler to be called always you should register the handler with 1 as the call_always field value otherwise 0

h2. Api internal work

There isn't much to the internals of the Api. After a tvlv is registered, on the next ogm interval the append function is called which goes through the tvlv_out_list and copies tvlvs to the end of the ogm packet. On receiving, the tvlv_process function goes through the appended tvlvs, parses them and if there is a handler registered for the tvlv, it calls the appropriate callback.
Then it calls all the  call_always callback functions for which a tvlv wasn't received.

h2. Features converted

Currently there is only the gateway feature which is fully implemented and running.
Translation table is work in progress and will be finished soon.
Next feature is vis.