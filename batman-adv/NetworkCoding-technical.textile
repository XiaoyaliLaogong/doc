h1. Catwoman

When forwarding packets in a wireless mesh network, airtime can be saved by exploiting the information already present at the destinations of a forward. One way of doing this is _Network Coding_, where two packets are XOR'ed together before transmission. To extract one of the included packets, the destination must simply XOR the network coded packet with the other included packet:

<pre>
  (p1 XOR p2) XOR p2 = p1
</pre>

For more information about the concept, read the news item about [[open-mesh:2011-08-18-network-coding-first-steps|Batman and Catwoman]].

h2. Implementation Details

The implementation is based on 5 steps:

# *Detect neighbors that are in range of each other*: This enables the relay to determine if a neighbor is likely to overhear packets from another neighbor.
# *Hold back unicast packets before forwarding*: To get two packets to code, one must be buffered until the next arrives.
# *Code and transmit combined packets*: This step searches the buffer with packets to be forwarded and checks if the destinations will be able to decode.
# *Save overheard and transmitted packets*: To decode a a packet, the receiver must know one of the two combined packets, which can either originate from the receiver itself or be sniffed from another neighbor.
# *Receive and decode network coded packets*: When receiving a coded packet, the overheard and saved packets are searched for the packet needed to decode.

Each step is explained in detail in the following sections.


h3. 1. Detect neighbors in range of each other

A relay node exploits the TTL field of OGMs to detect when two neighbors are in range of each other:

Node A emits an OGM, which is received by Node C and Node R.

!ogm_step1.png!

Node C decreases the TTL retransmits the OGM from Node A. The OGM is again received by Node R, who compare the TTL of the two received OGMs.

> !ogm_step2.png!

If the difference if only 1, Node R can conclude that Node C is in range of Node A.


h3. 2. Hold back unicast packets before forwarding

Whenever a unicast packet is ready to be forwarded, it is passed to the network coding system, where it added to a buffer (only if not coded with an already existing packet). The buffer is organized as a hash table with entries of src-dst pairs. Each entry has a linked list with packets that all come from a specific previous hop and are directed to a specific next hop (which is decided by the routing part of batman-adv). The linked list works as a FIFO:

!packet_pool.png!

A worker function traverses the list periodically and transmits timed out packets. The timeout is by default 10ms.


h3. 3. Code and transmit combined packets

Before adding packets to the forward buffer, the buffer is searched for opportunities to network code. The algorithm to find such opportunities takes its starting point in the packet currently being added to the buffer, say /p1/:

# The destination of a potentially network coded packet must be in range of the *source* of /p1/, so we loop nodes in range of the source of /p1/.
# Since we also need the *destination* of /p1/ to be in range of another node, we loop the nodes that the destination is in range of.
# For each pair of nodes in the two loops, we check of buffered packets and network code if any.


h3. 4. Save overheard and transmitted packets

To be able to decode network coded packets, a node must possess one part of the coded packet. This is achieved by buffering both packets originating at the node and packets overheard by the node. The buffer is structured in the same way as the forward buffer in step 2, which makes is fast to search for decoding packets. To overhear packets from other nodes, the wireless interface must be put in promiscuous mode.


h3. 5. Receive and decode network coded packets

To transmit a network coded packet to two destinations, the address of the additional receiver is put the batman-adv header, and thus this receiver is required to use promiscuous mode. Furthermore, the header contains information needed to identify the id of the original packets contained in the network coded packet.

To identify the packet needed to decode, the receiver uses the source of the network coded packet, and a field in the header with the address of the sender of the original packet. These addresses are used to create a src-dst pair, which is used to locate the correct entry in the hash table, in which the packet list is searched for a matching CRC, which is also given in the header of the network coded packet.

When the needed packet is located, its data is XOR'ed with the network coded packet, and the original unicast header is restored so that it can be processed as usual by batman-adv.


h2. Required Work

To make the implementation of catwoman complete, the following features must be implemented:
* -Remove outdated nodes from the list of coding neighbors periodically.-
* Support fragmented unicast packets.
* -Use the link quality of overhearing links when looking for coding opportunities.-
* -Support configuration with batctl.-
* -Use bat_dbg instead of printk.-
* Support setups with multiple interfaces. (Need to make sure that nc_nodes are on the same interface.)
* -Maintain ref-counters for struct orig_node.-
* -Refactor code into three files: catwoman.c, coding.c, and decoding.c-
* -Remove nc_path after a certain timeout.-
* Determine allowed holding times based on the tick time of the system.
* -Collect nc-related members of bat_priv in a nc-struct.-

h2. Ideas

* Send coded packets containing redundant packets to improve reliability.
* Support the cross topology where more than two destinations are coded.
* Implement Random Linear Network Coding (RLNC) on packets from the same flow, also to improve reliability.
* -Use checksums instead of packet_id's to identify decoding packets.-
* Implement a "catwoman-support"-flag in OGM to allow mixing of nodes with and without catwoman enabled.
* -Refactor function names and variables to cw_* (or nc_*) instead of catwoman_* and coding_*.-