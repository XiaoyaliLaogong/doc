h1. BANDWIDTH METER TECHNICAL and DEBUG PAGE

h2. Window Size

Window size is an upper bound for throughput. At most a window is sent every RTT. But every time a packet is lost, the whole window is retransmitted!
With packet size 1500 bytes, RTT 100ms the maximum throughtput is:

WINDOW_SIZE 100: 1500000 ~ 1.5 MB/s

h2. CONCURRENT ACCESS

Two data structures are shared:
* struct list_head bw_list, part of bat_priv;
* structure bw_vars, bw_list elements and "connection" specific: one bw_vars exists for each source or destination;

Every time a packet is received, wether of type BW_METER or BW_ACK, the bw_vars struct associated with the connection is searched. If the packet initiates a new connection, the structure must be allocated. List searches and modifications are protected with a spinlock, bw_list_lock, that is declared in bat_priv.
The protection of struc bw_vars is more complex and differs in the sender and in the receiver.

h3. The Sender

The sender accesses the struc bw_vars in two points in the code:
* upon an ACK reception, in the function batadv_bw_ack_received: ACK's seqno is compared with window_first and if the ack is valid, window_first is increased.
* in the function send_remaining_window() next_to_send is read and wrote, window_first is read.

ACK's handler executes atomically, using a spinlock declared in bw_vars as bw_ack_lock.

The function send_remaining_window(), in a similar fashion, is protected with bw_send_lock, also decleared in bw_vars struct.
No two send_remaining_window() should be running at the same time.

At the end of the ack's handler _batadv_bw_ack_received()_, a call to _send_remaining_window()_ is made: because the window slit, it should be possible to send new packets. But if the function is already running, it is useless to re-call it and it may lead to packet re-transmission. The value window_first, which determines the window slide, is never modified in the function _send_remaining_window_, so it should be possible to update it only (maybe an atomic value is safer??).

The solution with a single spinlock for both ack and send has been discarded: if the window is too big, while still sending packets the first acks arrives, but cannot be processed. This leads to acks starvarion and possibly to packet-retransmission.

h3. The Receiver

The receiver uses a single spinlock to protect the bw_vars structure: the only operation is indeed to increase the variable window_first and send an ack. This should not take much time since the ack is then send outside of the cs. Concurrent access occurs only if while processing an ack another one is received, which should be prevented by the use of the lock.


h2. BUGLIST

* -receiver freezes after test completion- *last packet was sent twice!!*

* Sender keeps resending the whole window every 400 ms, even with perfect networks. Presumably it is a concurrency-related problem since it shows only on some kind of machines (not mine). *About this bug, branch montik/debug1 and following detailed description*

Sometimes RESEND WHOLE WINDOW is triggered even with perfect line (qemu emulation). 
The function batadv_bw_worker should be called every 40 ms to check if the "timeout" has expired (400 ms has passed without sending something). The timeout is checked against the variable bw_vars->last_sent_time, which gets updated everytime a packet is sent out. With ordex we logged a behaviour of the type:

<pre>
CALL to batadv_bw_worker -> last_send_time: n
CALL to batadv_bw_worker -> last_send_time: n
CALL to batadv_bw_worker -> last_send_time: n
CALL to batadv_bw_worker -> last_send_time: n
CALL to batadv_bw_worker -> last_send_time: n
RESEND WHOLE WINDOW
</pre>

So the worker's called few times in a row and at the end the whole window is resent. *this happens only with big window (i.e. > 1500 packets)*.

*PROBLEM 1)* I tried to run the test with a window size *greater* than the total amount of packets to send, disabling the worker and any further call to the function multiple_send: a single call to this function in batadv_bw_start should be enough to send all the packets and successfully accomplish the test. 
But, every time, the algorithm stops around packet 1300: the receiver doesn't receive any more packet, so it doesn't send back any ACKs, deadlocking the system (since worker is disabled). This behaviour could be reasonable on a real network, not on an emulated, loss-free, one.

Probably packets are dropped at sender side: since the window is so big, 2000 packets are sent in a row, creating a packet burst that probably is too much for the underlying (emulated) hardware. Thus when the buffer is full they are dropped.

*PROBLEM 2)* In this debug1 branch, all the spinlocks are commented and the worker just prints a message (the bw_vars->last_sent_time) and re-inserts himself into delayed work queue (to be executed after 40ms). Thus one expects that, since network has no delay nor loss, packets are sent and received and that roughly every 40ms a message is printed on kernel logs by the worker.
But : while multiple_send is in execution, the worker is never called, while the worker is in execution, multiple send is never called! So we have something like

<pre>
0ms -> start the test                      *SENDING/ACKING*
        ->enqueue work
        ->call multiple send
0+ ms -> send packet 0
.....
0+ ms -> receive ack p
0+ ms -> send packet p+1
.....

K ms -> send packet ~1300

0+ ms -> worker called: last send time : K     *NOT SENDING/NOT RECEIVING ACKS*
0+ ms -> worker called: last send time : K
0+ ms -> worker called: last send time : K
0+ ms -> worker called: last send time : K
....
K+400 ms -> worker called: last send time : K
RESEND WHOLE WINDOW
                                             *SENDING/ACKING AGAIN *
.......
</pre>

The nodes go on like this until all packets have been sent. The worker is never called while sending packets, not until 1300 packets have been sent. The reason is simple: the worker gets called when the protocol is stuck, as in PROBLEM 1. If the protocol is stuck, the worker is called every 40ms. It invokes multiple_send, but the function does nothing as the window has been fully sent (to module eyes...) and no new acks have been received. Two problems: why the packets are discarded (or does it make sense to use such a big window??) and *why* worker is not called before (note that worker execution can even be delayed for tens of seconds with smaller windows that don't cause the protocol to get stuck)?

h2. Documentation

 * "data alignment in the kernel":http://www.mjmwired.net/kernel/Documentation/unaligned-memory-access.txt

 * "skb":http://vger.kernel.org/~davem/skb.html

 * "DELAYED_WORK":http://www.ibm.com/developerworks/linux/library/l-tasklets/