h1. How to Interconnect different Batman-adv clouds (DRAFT)

h2. Overview

A scenario which is becoming more and more common in mesh deployments is the existance of two or more batman-adv clouds interconnected via Layer3 routing.
This is a normal consequence of the hierarchy introduced into a network in order to make it scale.

A batman-adv cloud is a set of nodes which are all using batman-adv and so they are all sharing the same broadcast domain (meaning they are all in the same subnet). Many of these clouds can then be interconnected by means of Layer3 gateways which do usualy run a different routing protocol aimed to find the best Layer3 path between the source and the destination cloud.

A very common situation can be the one depicted in the following picture, where one cloud may have more than one Layer3 exit point with different costs towards the final destination.

!batman-l2-l3.png!

Node A and B are the two possible exit points from cloud1 towards cloud2, while D and E are the two cloud2 entry points. In the normal "Gateway":http://www.open-mesh.org/projects/batman-adv/wiki/Gateways scenario batman-adv would choose the gateway which is reachable through the path with the Best TQ. In the picture node C would choose A because the TQ towards it is 90%25 while towards B it is 80%25. This seems to be the best choice because this way batman-adv is minimizing the probability of packet loss till the gateway, but it is not considering the rest of the path behind it towards the real destination: cloud2.

Looking at the scenario with more attention it is possible to understand that choosing B as exit point is better because the resulting overall qualities are the following:
* C -> A -> D : TQ = 90%25 * 50%25 = 45%25
* C -> B -> E : TQ = 80%25 * 100%25 = 80%25

Given these results it is possible to understand that the best local choice (node A) would result in a worse overall path towards cloud2.
This conclusion lead to the problem that the local available information in a batman-adv cloud is not enough to make a proper decision at the source (node C).

h2. The idea

Injecting into the batman-adv cloud information about the external links can result in the possibility for any batman-adv node to compute the overall metric towards the selected destination (e.g. cloud2) and so to choose the "real best" exit point .

Imagine that in the scenario shown in the previous picture node C knows about the TQ between A and D and between B and E: it would have chosen node B because it minimize the *overall* packet loss towards its destination (cloud2).

To implement this concept batman-adv needs:
# a border gateway selection
# a metric injection and combination mechanism
# a layer3 metric propagation

For 1 we use L2 anycast, a particular GW tvlv with subnets announcement, a TT_CLIENT_GW flag, a virtual GW table, possibly DHCP and L3 routing daemon interaction.
For 2 and 3 we use batman-adv on the external link as well. This give as a metric which can be easily combined into the batman-adv cloud (the metric inside and outside the cloud are the same and can be combined with the classic batman-adv schema).

h2. Layer-2 Anycast

L2 Anycast consists in assignng the same MAC address to two *different* non-mesh clients and in leaving to batman-adv the decision of which one should be contacted.
Batman-adv will choose the best path towards the client (which looks like being one only since the two hosts have the same MAC address) on a metric basis.

This mechanism works thanks to the Bridge Loop Avoidance II component which allows the same client to be reachable via different originators. The L2 Anycast exploits this feature by placing several non-mesh clients in the network having the same MAC address.
The result will be again that *batman-adv will try to contact the client behind the best path*.

The macvlan kernel module can be used to create several virtual interfaces on top of an already existing one. The new interfaces can have a user defined MAC address and will not apply any tagging, this way it is possible to create as many non-mesh clients as the user wants on the same node.
This is an example on how to create a virtual interface on top of another one:
<pre>
# ip link add link bat0 name veth0 type macvlan
</pre>

h2. Border Gateway Advertisement

Once the Layer2 Anycast has been settled each batman-adv node needs to know which are the external costs to be able to choose the "overall best" exit point. To do so batman-adv uses a new GW advertisement message which will contain the destination subnet, the MAC address used by the GWs and the cost towards the destination. This information is encapsulated in a proper TVLV, the *Border GW TVLV*.

Each border gateway sends *one Border GW TVLV per subnet* that it can reach via Layer3. The TVLVs are appended to the OGMs as already done for other capabilities, so that each node in the network can acquire such information.

In a few words, whenever batman-adv wants to reach the MAC address used by a border GW (so a MAC address announced via the new GW advertisement) instead of running the normal BLA2 selection routine (which would choose the best originator serving that MAC address) a particular table containing the external cost to reach the associated subnet (there is a 1-to-1 relation between a GW-MAC and a subnet) via each *border-originator* is accessed so that batman-adv can select the node which minimizes the cost of the overall path. Such cost is given by the combination of the TQ towards the selected originator and the cost of the external link towards the subnet via such node.

h3. MAC Generation

A first consequence of this mechanism is that each border gateway which is able to route packets towards a given subnet has to create a client configured with a MAC address which has to be the same on all the gws. A client can be created as a virtual interface on top of the canonical bat0: to do this the administrator can use the _macvlan module_ as explained in the Layer2 Anycast section above.

The MAC address to assign to the virtual interface can be computed by a function _SubMAC(Subnet)_ so that, given a subnet S1, SubMAC(S1) gives the same result on all the nodes. It is also important that, given two subnets S1 and S2, SubMAC(S1) is different from SubMAC(S2) for every pair S1 - S2, therefore SubMAC must be built on top of a robust hash.

*Example function*:
<pre>
SubMAC(a.b.c.d/x) = 02:HEX(x):HEX(a):HEX(b):HEX(c):HEX(d)
</pre>

Setting the second LSB in the first octect of the MAC to 1 (meaning Locally administered address) should ensure that no standard client device should have such MAC address (unless manually configured).

TODO: what about aggregation? if a border GW aggregate and another does not, we end up with different MAC addresses and the L2 anycast won't work anymore...