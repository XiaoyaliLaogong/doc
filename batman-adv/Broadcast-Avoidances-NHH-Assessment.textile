h1. Broadcast Avoidances - Neighborhood Hash Assessment

h2. Throughput Rules Evaluation

h3. Example Scenario Evaluation

h4. Scenario A)

Assuming all nodes have a 1GBit/s connection to the switch. Then a node has for any neighbor:

<pre>
neigh->throughput
= neigh->min_throughput
= neigh->max_throughput
= iface->min_throughput_other
= iface->max_throughput_other
= 1000MBit/s
</pre>

That means the ingress TX, egress TX as well as ingress RX and egress RX check evaluate to:

<pre>
fwd-penalty(1000) < 1000
</pre>

Which is true as long as a hop penalty is configured (default).

This means, that a rebroadcast avoidance successfully takes place for scenario A).

h4. Scenario B)

h3. Concept

Let's start with a simple, three node example:

!rebroadcast-eval1.png!

_Should B rebroadcast?_

Here, A is our initial broadcaster and B the node having to decide whether or not to rebroadcast on the same, incoming interface.

To decide this, we will compare the direct path between A and C vs. the path from A to C via B:

!rebroadcast-eval2.png!

_Is (AB ⊕ BC) a shortcut or a detour?_

With a simple throughput metric the path from A to C via B is a detour exactly when either the connection from A to B or from B to C (or both) is a bottleneck. That is if either AB or BC offers a smaller throughput than AC.

That means B can perform an _ingress check_ (AB < AC?) and an _egress check_ (BC < AC?) individually.

To make sure, that a rebroadcast is unnecessary, B would need to perform such an ingress and egress check for any neighbor Cn (any neighbor other than A):

!rebroadcast-eval3.png!

If B notices that for all these neighbors Cn it is a bottleneck and no improvement then B can safely avoid a rebroadcast.

h3. Simplification

Instead of performing all the checks described above, the modified rules are used in the implementation with the following goals:

 * Less information to exchange
 * Less computational overhead
 * Supposed to work even with large neighborhoods

Performing the checks stated above has the following disadvantages: For one thing, the computational overhead could be significant for neighborhoods of a certain size. For another, B does not even know the throughput from A to B or A to C (or C to A or C to B - we will see later why we might need those). B only knows its own TX throughput towards other neighbors and not the other way around.

Instead of every neighbor node frequently broadcasting a full list of TX values and every neighbor performing all these checks for any neighbor with any neighbor combination, the implemented neighbor hash approach applies a huge simplification needing considerably less computations and information exchange:

Instead of checking all (AB < ACn?) and (BCn < ACn?) combinations, it tries to perform "one check that rules them all" (with the downside of maybe not catching all potential rebroadcast avoidance cases).

h3. Proofs

We need to ensure that avoiding a rebroadcast does not break our optimality promises. That is that we do not break that a route eventually converges to its optimum path.

While the assessment above showed when optimality is not broken, the following mathematic assessment shows that our slightly modified rules still hold optimality.

h4. Proof: Ingress TX (bcast)

We want to proof:

 * p(Amax) < Amin => p(AB) < ACn for any Cn.

One has:

 * a ≤ b => p(a) ≤ p(b)
 * AB ≤ Amax
 * Amin ≤ ACn

<pre>
AB ≤ Amax
=> p(AB) ≤ p(Amax)

p(Amax) < Amin
=> (p(AB) ≤ p(Amax)) < Amin
=> (p(AB) ≤ p(Amax)) < (Amin ≤ ACn)
=> p(AB) ≤ p(Amax) < Amin ≤ ACn
=> p(AB) < ACn
</pre>

h4. Proof: Egress TX (bcast)

We want to proof:

 * p(Bmax) < Amin => p(BCn) < ACn

One has:

 * a ≤ b => p(a) ≤ p(b)
 * BCn ≤ Bmax
 * Amin ≤ ACn

<pre>
BCn ≤ Bmax
=> p(BCn) ≤ p(Bmax)

p(Bmax) < Amin
=> (p(BCn) ≤ p(Bmax)) < Amin
=> (p(BCn) ≤ p(Bmax)) < (Amin ≤ ACn)
=> p(BCn) ≤ p(Bmax) < Amin ≤ ACn
=> p(BCn) < ACn
</pre>

h4. Proof: Ingress RX (OGM2)

We want to proof:

 * p(AB) < MIN<code></code>(Amin, Cn-min) => p(AB) < CnA for any Cn.

One has:

 * MIN<code></code>(a, b) ≤ b
 * Cn-min ≤ CnA

<pre>
p(AB) < MIN(Amin, Cn-min)
=> p(AB) < (MIN(Amin, Cn-min) ≤ Cn-min)
=> p(AB) < (MIN(Amin, Cn-min) ≤ (Cn-min ≤ CnA))
=> p(AB) < MIN(Amin, Cn-min) ≤ Cn-min ≤ CnA
=> p(AB) < CnA
</pre>

h4. Proof: Egress RX (OGM2)

We want to proof:

 * p(MAX<code></code>(Amax, Cn-max)) < MIN<code></code>(Amin, Cn-min) => p(AB) < CnA for any Cn.

One has:

 * a ≤ b => p(a) ≤ p(b)
 * MIN<code></code>(a, b) ≤ b
 * a ≤ MAX<code></code>(a, b)
 * AB ≤ Amax
 * Cn-min ≤ CnA

<pre>
Amax ≤ MAX(Amax, Cn-max)
=> (AB ≤ Amax) ≤ MAX(Amax, Cn-max)
=> AB ≤ MAX(Amax, Cn-max)
=> p(AB) ≤ p(MAX(Amax, Cn-max))

p(MAX(Amax, Cn-max)) < MIN(Amin, Cn-min)
=> (p(AB) ≤ p(MAX(Amax, Cn-max)) < MIN(Amin, Cn-min)
=> (p(AB) ≤ p(MAX(Amax, Cn-max)) < (MIN(Amin, Cn-min) ≤ Cn-min)
=> (p(AB) ≤ p(MAX(Amax, Cn-max)) < (MIN(Amin, Cn-min) ≤ (Cn-min ≤ CnA))
=> p(AB) ≤ p(MAX(Amax, Cn-max) < MIN(Amin, Cn-min) ≤ Cn-min ≤ CnA
=> p(AB) < CnA
</pre>

h2. Hash Collision Probability

sha512 provides 256 bits of security against collision attacks. With 4.8e29 inputs, that is with 4.8e29 different neighborhoods, we would have a collision probability of 1e-18.

This number of inputs would be reached if over 500 years a new neighborhood were formed 3e10 times per nanosecond.

See also:

 * https://en.wikipedia.org/wiki/Birthday_attack