h1. Broadcast Avoidances - Neighborhood Hash Assessment

h2. Throughput Rules Evaluation

h3. Introduction / Concept

Let's start with a simple, three node example:

!rebroadcast-eval1.png!

_Should B rebroadcast?_

Here, A is our initial broadcaster and B the node having to decide whether or not to rebroadcast on the same, incoming interface.

To decide this, we will compare the direct path between A and C vs. the path from A to C via B:

!rebroadcast-eval2.png!

_Is (AB ⊕ BC) a shortcut or a detour?_

With a simple throughput metric the path from A to C via B is a detour exactly when either the connection from A to B or from B to C (or both) is a bottleneck. That is if either AB or BC offers a smaller throughput than AC.

That means B can perform an _ingress check_ (AB < AC?) and an _egress check_ (BC < AC?) individually.

To make sure, that a rebroadcast is unnecessary, B would need to perform such an ingress and egress check for any neighbor Cn (any neighbor other than A):

!rebroadcast-eval3.png!

If B notices that for all these neighbors Cn it is a bottleneck and no improvement then B can safely avoid a rebroadcast.

h3. Simplification

Simple, ey? So we just try all these checks! - Not so fast...

Currently, we have two problems: For one thing, the computational overhead could be significant for neighborhoods of a certain size. For another, B does not even know the throughput from A to B or A to C (or C to A or C to B - we will see later why we might need those). B only knows its own TX throughput towards other neighbors and not the other way around.

Instead of every neighbor node frequently broadcasting a full list of TX values and every neighbor performing all these checks for any neighbor with any neighbor combination, the implemented neighbor hash approach applies a huge simplification needing considerably less computations and information exchange:

Instead of checking all (AB < ACn?) and (BCn < ACn?) combinations, it tries to perform "one check that rules them all" (with the downside of maybe not catching all potential rebroadcast avoidance cases).

h3. Proofs

h4. Proof: Ingress TX (bcast)

We want to proof:

 * p(Amax) < Amin => p(AB) < ACn for any Cn.

One has:

 * a ≤ b => p(a) ≤ p(b)
 * AB ≤ Amax
 * Amin ≤ ACn

<pre>
AB ≤ Amax
=> p(AB) ≤ p(Amax)

p(Amax) < Amin
=> (p(AB) ≤ p(Amax)) < Amin
=> (p(AB) ≤ p(Amax)) < (Amin ≤ ACn)
=> p(AB) ≤ p(Amax) < Amin ≤ ACn
=> p(AB) < ACn
</pre>

h4. Proof: Egress TX (bcast)

We want to proof:

 * p(Bmax) < Amin => p(BCn) < ACn

One has:

 * a ≤ b => p(a) ≤ p(b)
 * BCn ≤ Bmax
 * Amin ≤ ACn

<pre>
BCn ≤ Bmax
=> p(BCn) ≤ p(Bmax)

p(Bmax) < Amin
=> (p(BCn) ≤ p(Bmax)) < Amin
=> (p(BCn) ≤ p(Bmax)) < (Amin ≤ ACn)
=> p(BCn) ≤ p(Bmax) < Amin ≤ ACn
=> p(BCn) < ACn
</pre>

h4. Proof: Ingress RX (OGM2)

We want to proof:

 * p(AB) < MIN<code></code>(Amin, Cn-min) => p(AB) < CnA for any Cn.

One has:

 * MIN<code></code>(a, b) ≤ b
 * Cn-min ≤ CnA

<pre>
p(AB) < MIN(Amin, Cn-min)
=> p(AB) < (MIN(Amin, Cn-min) ≤ Cn-min)
=> p(AB) < (MIN(Amin, Cn-min) ≤ (Cn-min ≤ CnA))
=> p(AB) < MIN(Amin, Cn-min) ≤ Cn-min ≤ CnA
=> p(AB) < CnA
</pre>

h4. Proof: Egress RX (OGM2)

We want to proof:

 * p(MAX<code></code>(Amax, Cn-max)) < MIN<code></code>(Amin, Cn-min) => p(AB) < CnA for any Cn.

One has:

 * a ≤ b => p(a) ≤ p(b)
 * MIN<code></code>(a, b) ≤ b
 * a ≤ MAX<code></code>(a, b)
 * AB ≤ Amax
 * Cn-min ≤ CnA

<pre>
Amax ≤ MAX(Amax, Cn-max)
=> (AB ≤ Amax) ≤ MAX(Amax, Cn-max)
=> AB ≤ MAX(Amax, Cn-max)
=> p(AB) ≤ p(MAX(Amax, Cn-max))

p(MAX(Amax, Cn-max)) < MIN(Amin, Cn-min)
=> (p(AB) ≤ p(MAX(Amax, Cn-max)) < MIN(Amin, Cn-min)
=> (p(AB) ≤ p(MAX(Amax, Cn-max)) < (MIN(Amin, Cn-min) ≤ Cn-min)
=> (p(AB) ≤ p(MAX(Amax, Cn-max)) < (MIN(Amin, Cn-min) ≤ (Cn-min ≤ CnA))
=> p(AB) ≤ p(MAX(Amax, Cn-max) < MIN(Amin, Cn-min) ≤ Cn-min ≤ CnA
=> p(AB) < CnA
</pre>