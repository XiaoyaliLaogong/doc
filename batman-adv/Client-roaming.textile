h1. Roaming-improvements

h2. Speeding up the roaming

The base idea consists in exploiting the new forwarding mechanism for data packets described in the [[Client-announcement]] page in order to reduce the interruption time a non-mesh client experiences when moving from one mesh node to the next. This procedure of a non-mesh client switching to a new mesh node is called "roaming". At its core it simply is a synchronization issue: Whenever roaming occurs the new mesh node "parent" needs to inform the entire mesh that a particular non-mesh client is now to be found at a new location. Even under ideal conditions it might take a full originator interval in which the client is not reachable at all. The bigger the mesh, the higher the packetloss or originator interval the longer the client has to wait before it can use the network again.

The main idea behind the roaming improvements is to make use of the fact that batman-adv has full control over the payload traffic traveling through the mesh network. In particular, with this mechanism the packet destination is modified along the path, if needed, as the message reaches an up-to-date router. If so data packet is rerouted to the new destination and information in the packet header are updated too (destination and ttvn field) until the mesh network is in sync again. In addition, a roaming advertisement packet is sent to immediately inform the old originator that the client has moved and that it is now located on another node. This message can be seen as an asynchronous update that permits the old node to redirect data packets as soon as they reach it.

h2. Roaming advertisement

The roaming advertisement format:

* Packet type: Initialize this field with the ROAM_ADV packet type.
* Version: Set your internal compatibility version.
* Destination Address: Address of the host this packet should be forwarded to.
* TTL: Time-To-Live field decreased by with one with each hop. Packet is to be discarded when counter reaches 0.
* Source Address: Address of the host sending this message.
* Client Address: Address of the roaming client that the source node has to communicate to the destination one in order to update the global translation table.

<pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 | Packet Type   |    Version    |      TTL      |     Align     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                       Destination Address                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |      Destination Address      |         Source Address        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         Source Address                        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         Client Address                        |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |         Client Address        |                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

These information are used to update the old node's global table so that, in case of payload packet directed to him while the network is not in sync, with a payload destination equal to 'client address is redirected to 'source address'.

Due to this mechanism, immediately after a roaming the data packets might follow a slightly sub-optimal path (data flow is going through the old node) until the network is in sync again and every node has updated its global translation table. This strategy will help to avoid losing packets that are still flowing to the old node.

h2. Routing data packets

The basic routing procedure is the same described in the [[Client-announcement]] page. The only difference consists in giving the routing node the possibility of inspect the data packet (to possibly change the destination) even if the TTVN carried by the packet is not less than the one the router knows.
This chance must be given only in a case: the destination node is in *roaming phase*.

The **tt_poss_change** flag in the originator structure is used for this purpose. It is set tu true in case of receiving a ROAMING-Advertisement from an originator an it is set to false again once a new OGM is received from the same node.

h2. Detecting a roaming phase

To detect a roaming phase, a node in case of new local client detection will look into its global translation table for the address of the new host. In case of positive match (the same MAC address is already in the table but pointing to another originator) the new mesh node will send a **ROAMING-Advertisement** message to the old node serving this client so that it will be able to update its global table and possibly redirect packets to the new mesh node.

h2. Keeping table consistency

As described [[Client-announcement|here]] each node computes its local tt_crc value and spread it over the network using the OGMs. In case of roaming, a temporary inconsistent global table could lead to a wrong (global) tt_crc value computed on the nodes making them issue a new TT_REQUEST.

In particular, a node receiving a Roaming-Advertisement message will track this change as a simple removal and will send it within the next OGM. The receiver node has to **do not delete** this client immediately, otherwise it will lose any route towards it.
So the idea is to keep the client entry in the nodes global tables. By the way this solution could lead to an inconsistent state: if client C roams from A to B, A won't have C in its local table any more, but nodes keeping this entry pointing to A will then compute a wrong (global) tt_crc value for A (they are using C in the computation).

To solve this issue, a new flags field has been added to the tt_change and the tt_global_entry structure. In particular, every **delete** change generated by a roaming event will have the TT_CHANGE_ROAM bit set so that receiving node can set the corresponding TT_GLOBAL_ROAM flag in the tt_global_entry it is going to modify/create. This flag will slightly modify the tt_crc computation for global tables: entry with TT_GLOBAL_ROAM set will not be used for the computation to reflect the state of the originator's local table keeping a valid route to clients at the same time.

The TT_GLOBAL_ROAM in the tt_global_entry structure will be reset to 0 as soon as a new OGM containing an **add** event for that client is received.

(to be reread/reviewed)

h2. Limitations

- **MAC conflict**: In case of more than one node announcing the same client MAC address, each node will interpret this situation as a "continued roaming" and will start sending ROAMING-Advertisement multiple times. To reduce the impact of this problematic scenario a **roaming-protection** has been provided: A client con roam on the same node a fixed amount of times in a fixed length period (look into main.h for the exact values). In case of exceeding the limit, the interested node will not issue any new ROAMING-Advertisement unless the protection period is terminated.

- **Multiple-roaming in one OGM interval**: In case of a node roaming from node A to B a ROAMING-Advertisement is sent from B to A, but if the client moves again from node B to C, before B issued a new OGM, C will send the ROAMING-Advertisement to A again!! This happens because C doesn't know anything yet about the last client movement. **A possible solution to this problem could consists in implementing a ROAMING-Advertisement forwarding procedure that in scenarios like this make the ROAMING-Advertisement message going through all the steps the client did. By the way this feature is not critical**

h2. Notes

A research project has been done on this topic and it will be linked on this page as soon as it get ready.