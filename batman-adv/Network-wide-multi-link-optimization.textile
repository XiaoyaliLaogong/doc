h1. Network Wide Multi Link Optimization

The original batman-adv multi link optimization ([[Multi-link-optimizations-technical]]) works on a local level - which is fairly easy to implement and works well as long as as all nodes are configured the same way and have similar link qualities. But local decision may be wrong network wide - for example, consider some dual radio mesh nodes where the first node starts on 5 GHz, but after some hops (after switching between 2.4 and 5 GHz) it stops at a 2.4 GHz-only device. If it had chosen the other (2.4 Ghz) link in the first hop, choosing the same frequency twice could have been avoided, and the total path quality would be better.

!alternating-limited-view.png!

This limitation can be solved by relaying the information about multi interfaces over the whole mesh. This requires some changes to routing and forwarding, which are to be described here. (Original concept by Antonio)

h2. Routing Table Per Interface

The main idea is to use n + 1 routing tables instead of just one, with n the number of interfaces:

 * there is one routing table based per incoming interface
 * one extra routing table for packets generated locally (e.g. from soft-interface)

The routing table is chosen based on the interface where the packet comes from.

h2. OGM forwarding and penalties

To propagate different paths, the OGM forwarding is changed:

 * When there are multiple interfaces and an OGM is forwarded on the same interface, an additional penalty (e.g. "half duplex penalty) when re-forwarding the OGM on the same interface
   -> the metric with the *applied* penalty is stored locally
 * apply the strict "forward only from best neighbor" per interface

+Path Metric computation+
Each node, say SRC, creates and sends its own OGMs to let all the other peers in the network build their routing table
* For each interface I belonging to SRC:
** one OGM is sent as broadcast over I containing the link metric value (namely OGM.metric) equal to 0
* A generic node P receiving an OGM from R on interface I_IN
** computes next_hop_metric = nhm(OGM.metric, R, I_IN)
where nhm(x, r, i_in) is a metric alterating function which computes the path metric towards OGM.SRC by combining OGM.metric and the estimated throughput on the link P <-> r (through interface i_in).
** For each interface I
*** computes forw_metric = fwm(next_hop_metric, I_IN, I)
where fwm(x, i_in, i) is a metric alterating function which computes the metric value that a node has to propagate over the given interface i that the path goes through interface i_in
*** a new packet OGM' is created and OGM'.metric = forw_metric is set
*** OGM' is sent as broadcast over I
* Information to store in the routing table
** one classic routing table for *each interface* containing
*** the best next-hop towards each possible destination: the best next-hop is chosen based on the best next_hop_metric towards the destination

For example, consider the following illustration:

!alternation_chain.dia.jpg!

We consider all link qualities equal. What should happen according to the rules (after some OGMs):

 * OGMs from A are sent via A1 and A2
 * B applies the new penalty when forwarding packets from A1 again on B1, and also when forwarding from A2 on B2
 * therefore, As OGM received on B1 are only forwarded on B2 (because no penalty is applied here). They are not re-forwarded on B1 because for this interface, the packets received on B2 have a better quality.
 * finally (assuming equal link qualities everywhere), the TQ values in the OGMs from A forwarded by B are equal too - but the internal routing table include the interface switching
 * putting it all together and assuming the other nodes behave the same way: If a packet is sent by D on D1, it will follow the dashed path. If it is sent on D2, it will follow the solid path. The interface alternation was implemented by local routing table decisions but forwarded information (unlike the original local-only interface alternation).

h3. Another example: path diversity

!net-wide-multiif.png!

Scenario:
* Node B is equipped with 2 interfaces (imagine two wifi cards with sectored antennas)
* Node A is connected to B through B1 and uses B as next hop towards E
* Node F is connected to B through B2 and uses B as next hop towards E
* All the links are perfect
* Packets sent by A intended to E are received by B on B1 and forwarded using B2
* Packets sent by F intended to E are received by B on B2 and forwarded using B1
* B's nexthop to E using B1 is different from B's nexthop to E using B2

The presented example is another consequence of the mechanism explained in this page.
Since the multi-interface optimisation is not per-link anymore but is now defined network wide, *packets can possibly be routed through two completely different paths in order to reach the same destination*.

This possibility is given by the fact that on the path from A to E  B will choose G as best next-hop, while on the path from F to E B will choose C.

The result is that, with this new feature, multi-interface nodes can act as routing splitting point which leads to a first tempative of real multi-path routing.

h3. Ideas for the future

* Theoretically, a node generating traffic instead of using its own routing table could exploit the path diversity and route its traffic using all the routing tables of all the interfaces (the selection policy have to be defined..round robin would not work properly because when using two different paths TCP reordering may decrease the performance)