h1. *BANDWIDTH METER*

h2. Branches

 * http://git.open-mesh.org/?p=batman-adv.git;a=shortlog;h=refs/heads/montik/bw1
 * http://git.open-mesh.org/?p=batctl.git;a=shortlog;h=refs/heads/montik/bw1

h2. GENERAL DESCRIPTION

The project aims to create a kernel-space tool that measures the throughput between two nodes and avoids problems experienced with user-space tools like iperf and netperf. With those tools main problems are encountered on machines that are low on resources, including routers, since packets must be copied from kernel-space to user-space memory and aligned. On such devices this computational load can slow the device itself, leading to packet losses at the receiver side, thus altering the test result. Two modes are implemented:

* tcp-like: in this mode the behaviour of tcp should be re-created. We should verify if it is possible to use the existing, standard, tcp implementation or if it is needed to develop a tcp-like (simpler...) protocol just for this application.
** Using kernel TCP stack is too complex and the problem of unaligned data remains. Furthemore it requires an IP address for the destination.

* udp-like: one directional, no retransmission, stream of data;
** How to ensure that all data was transmitted
** How do we ensure that the last packet/magic packets were not transmitted out of order
** how does the remote node gets informed that test finished even when *many* packets are dropped

The test is started through batctl:

<pre>
batctl bw <MAC ADDRESS>
</pre>

when the test is over the throughput is returned.

h2. TODO

* keep a counter for the number of retransmission of the same window
* keep track of already received packets
* use the msg-type and not the header size to distinguish between bw_meter and other icmp packets
* furthemore, wsize is not used by now, and it's the only differnece between icmp_packet and icmp_packet_bw. Does it make sense to maintain a different header? If we remove, what about new features that must be introduced (e.i. sender/receiver choice)?
* use bitarray to implement sliding window: doubts: 
** in the sender why do I need a bitmap? I am currently only using three variables.
** in the receiver is it suitable? It seems that window is shifted for every *"valid"* packet that is received (i.e. packets that belongs to the window), even if the window has holes, which is ok for cumulative acknowledgment or similar, but not for packets received.
* test protocol for deadlock situations ("spin":http://spinroot.com/spin/whatispin.html)
* sockets usually use sk_*_timer functions to manage the timers, wait_event_interruptible for the wait and wake_up_interruptible to wake up the waiting timers and wait_event_interruptible_timeout is the thing to get waked up
* what is a reasonable window size? See window size at the bottom of the page
* enable lockdep in the test kernel
* No strange locking; http://rswiki.csie.org/lxr/http/source/arch/x86/kernel/cpu/mtrr/generic.c?v=linux-2.6.33#L582
* Return a special packet to batctl when the test is over;
* add error handling in batpriv (look at ping and traceroute for examples);
* not wrap around safe (see batadv_seq_after, batadv_seq_before)
* the connection termination requires the receiver to wait a certain amount of time. A "three way" termination could speed up things. Is it a good idea??
* hton/ntoh

* -create a list for bw_meter_vars or store it in origin_node? A list in bat_priv should be enought, since not many test would be run concurrently.- *list in bat_priv*
* -concurrent access: check bw_meter_start concurrent access to bat_priv-
* -account for the received size (check last pkg).-
* -sometimes packets are not received- seems solved
* -react to the ack reception : *kernel panic with cancel_delayed_work_sync* !!- implemented with worker, so never remove a work from queue
* -initialize data structure on receiver side- used the same of the sender
* -bug when send_whole_window is called by worker. Access to freed memory-
* -can use __be16 seq of icmp_packet instead of a uint32_t offset ?? Are 16 bit of sequence number enought? 1500*2^16=93MB (seq can also wraparound??)- *Yes to both* use seq and consider wrapping 
* -return the exit status in auxiliary functions-
* -generate the ack-
* -timeout {delayed work};-
* -send all the window;-
* -define and initialize a data structure bw_meter_vars for variables used. The structure should be sender-dependant; [Adding it to bat_priv by now]-

* -define the BW_METER icmp packet header in packet.h- 
<pre>
/* icmp_packet_bw must start with all fields from imcp_packet
 * as this is assumed by code that handles ICMP packets
 */
struct icmp_packet_bw {
        struct batman_header header;
        uint8_t  msg_type; /* see ICMP message types above */
        uint8_t  dst[ETH_ALEN];
        uint8_t  orig[ETH_ALEN];
        __be16   seqno;
        uint8_t  uid;
        uint8_t  reserved;
        uint32_t offset;
        uint32_t wsize;
} __packed;
</pre>

* -upon batcl bw invocation a single BW_METER is sent to the destination. Destination by now only logs the packet is received; tested ok with vm;-
* -define and implement user-space interface (through batctl) [options still to be added]-
** -created files bw_meter.c in batman-adv and in batctl
if batctl bw is invoked from the command line, a function in kernel space get called, in a similar fashion as for ping (but the packet will be generated in kernel space)-

* -define the protocol, based on Go-Back-N-
* -set up virtual machines for testbed: using two virtual machine with Debian and kernel 3.2.12 to test the modifications introduced in order to call the bandwidth meter through batctl; the two machines are attached to two tun interfaces bridged together.-

h2. BUGLIST

* -receiver freezes after test completion- *last packet was sent twice!!*

* Sender keeps resending the whole window every 400 ms, even with perfect networks. Presumably it is a concurrency-related problem since it shows only on some kind of machines (not mine). *About this bug, branch montik/debug1*

Sometimes RESEND WHOLE WINDOW is triggered even with perfect line (qemu emulation). The function batadv_bw_worker is called every 40 ms to check if the ``timeout" has expired (400 ms has passed without sending something). The timeout is checked against the variable bw_vars->last_sent_time, which gets updated everytime a send is invoked. With ordex we logged a behaviour of the type:

CALL to batadv_bw_worker -> last_send_time: n
CALL to batadv_bw_worker -> last_send_time: n
CALL to batadv_bw_worker -> last_send_time: n
CALL to batadv_bw_worker -> last_send_time: n
CALL to batadv_bw_worker -> last_send_time: n
RESEND WHOLE WINDOW

So the worker's called few times in a row and at the end the whole window is resent. *this happens only with big window (i.e. > 1500 packets).

I tried to run the 





h2. SPECIFICATION

# the protocol will be a "Go-Back-N":http://en.wikipedia.org/wiki/Go-back-N: a fixed window, cumulative acknowledgment when a packet is received; this is intended as a rough approximation of the TCP behaviour;
# The user specifies how much data the bandwidth meter is intended to send in the session; once the transmission is completed (i.e. all the data is received by the sender) the transmission time is reported. _Further details on time computation to be added_; It should allow:
## Possibility to specify if the node is sender or receiver (data flow direction);
## Possibility to add others operation modes later (e.g. "UDP" mode);
## Integrated in the batman ICMP protocol; 
## The test is initiated through batctl. The user specifies at least the destination, the amount of data to be sent, if it is sender or receiver.

h2. PROTOCOL 

The protocol is connection oriented. Of the two end nodes, one is the sender and the other the receiver; their behaviour is described in the next sections.

During all the test ICMP packets only are exchanged, so two fresh ICMP packet types are defined in packet.h: 
<pre>
 47 enum icmp_packettype {
 ... ... ... ... ... ... .. .. .. ... ... ... ... ... ...
 53         BW_METER                = 15,
 54         BW_ACK                  = 16,
 55 };
</pre>

In order to provide an easier protocol to implement, Go-Back-N is used, with a static window. The window is made of BW_WINDOW_SIZE packets. At the moment the value is hardcoded, but in the future this could be specified by the user.

h3. The sender

The sender maintains, for each ongoing test, the following variables:

# total_to_send: total amount of data to send;
# next_to_send: next packet in the window that is to be sent
# window_first: sequence number (i.e. packet number) of the first packet of the current window

To begin the test, the sender sends BW_WINDOW_SIZE packets in a burst and starts a timeout, waiting for an ack. An ACK is an ICMP packet of type BW_ACK that carries the sequence number of the last received packet *in order* (cumulative acknowledgment), meaning that all the packets up to that sequence number have been received. If the ACK for a packet is not received before the timeout expires, all the unacked packets in the window are re-transmitted. Notice that there is no buffer, just the three variables that "emulates" it. 
The sender ICMP packet has type BW_METER, a 32 bit packet number and a 32 bit window size.

So BW_WINDOW_SIZE packets are sent, then the a timeout is started:

* when the timeout expires, the whole window is transmitted again. This means BW_WINDOW_SIZE packets are transmitted, with sequence numbers starting from window_first;
* if an ack is received, flush the timer. Update window_first to ack's "sequence number" and send from next_to_send to (window_first + BW_WINDOW_SIZE) new packets (with seqno starting from next_to_send). Every time a packet is sent, next_to_send is increased.

h3. The receiver

To begin the test, the receiver must receive the packet with seq 0: if another packet is received, the test is not considered started, no ack is sent back and no data structure is allocated on the receiver side. 

If the packet number zero is received and no other bandwidth test is ongoing with the same node, the connection is consiered open.

The receiver basically keeps a single variable, the beginning of the window:

# window_first: the sequence number of the first packet of the window

If a BW_METER packet is received on that connection, it's offset is checked: if it belongs to the window, shift window_first and send back an ack. Otherwise, just send back an ack to avoid protocol deadlock.

When a packet that is not full (its full size is different from that of the others) is received *in order* the test is finished. Send a normal ack back with the sequence number of the short packet, wait a certain amount of time and "declare the test finished" (i.e. free variables and accept new test packets). 
The time to wait should be greater than sender's timeout + RTT: if the last ACK is lost, the sender should re-send all the missing packets of the last window after the timeout expires. For each packet that is received, receiver will be send back an ACK, all with the same sequence number (i.e. the last sequence number expected).

h2. CONCURRENT ACCESS

Two data structures are shared:
* struct list_head bw_list, part of bat_priv;
* structure bw_vars, bw_list elements and "connection" specific: one bw_vars exists for each source or destination;

Every time a packet is received, wether of type BW_METER or BW_ACK, the bw_vars struct associated with the connection is searched. If the packet initiates a new connection, the structure must be allocated. List searches and modifications are protected with a spinlock, bw_list_lock, that is declared in bat_priv.
The protection of struc bw_vars is more complex and differs in the sender and in the receiver.

h3. The Sender

The sender accesses the struc bw_vars in two points in the code:
* upon an ACK reception, in the function batadv_bw_ack_received: ACK's seqno is compared with window_first and if the ack is valid, window_first is increased.
* in the function send_remaining_window() next_to_send is read and wrote, window_first is read.

ACK's handler executes atomically, using a spinlock declared in bw_vars as bw_ack_lock.

The function send_remaining_window(), in a similar fashion, is protected with bw_send_lock, also decleared in bw_vars struct.
No two send_remaining_window() should be running at the same time.

At the end of the ack's handler _batadv_bw_ack_received()_, a call to _send_remaining_window()_ is made: because the window slit, it should be possible to send new packets. But if the function is already running, it is useless to re-call it and it may lead to packet re-transmission. The value window_first, which determines the window slide, is never modified in the function _send_remaining_window_, so it should be possible to update it only (maybe an atomic value is safer??).

The solution with a single spinlock for both ack and send has been discarded: if the window is too big, while still sending packets the first acks arrives, but cannot be processed. This leads to acks starvarion and possibly to packet-retransmission.

h3. The Receiver

The receiver uses a single spinlock to protect the bw_vars structure: the only operation is indeed to increase the variable window_first and send an ack. This should not take much time since the ack is then send outside of the cs. Concurrent access occurs only if while processing an ack another one is received, which should be prevented by the use of the lock.

h2. Window Size

Window size is an upper bound for throughput. At most a window is sent every RTT. But every time a packet is lost, the whole window is retransmitted!
With packet size 1500 bytes, RTT 100ms the maximum throughtput is:

WINDOW_SIZE 100: 1500000 ~ 1.5 MB/s

h2. Documentation

 * "data alignment in the kernel":http://www.mjmwired.net/kernel/Documentation/unaligned-memory-access.txt

 * "skb":http://vger.kernel.org/~davem/skb.html

 * "DELAYED_WORK":http://www.ibm.com/developerworks/linux/library/l-tasklets/

 * TFTP ??