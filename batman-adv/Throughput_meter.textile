h1. *BANDWIDTH METER*

h2. Branches

 * http://git.open-mesh.org/?p=batman-adv.git;a=shortlog;h=refs/heads/montik/gsoc-final
 * http://git.open-mesh.org/?p=batctl.git;a=shortlog;h=refs/heads/montik/bw1

h2. GENERAL DESCRIPTION

This section explains the project aim and shows how to use the bandwidth meter. The protocol is described in the next section, while more technical details are discussed in the "technical and debug page":http://www.open-mesh.org/projects/batman-adv/wiki/GSOC2012_BW_debug

The project aim is to create a kernel-space tool that measures the throughput between two nodes and avoids problems experienced with user-space tools like iperf and netperf. With those tools main problems are encountered on machines that are low on resources, including routers, since packets must be copied between user-space and kernel-space memory and aligned. This computational load can slow such devices, leading to packet losses, thus altering the test result. A TCP-like mode is implemented to *approximate* TCP behaviour (the protocol is indeed much simple).

The test is started through batctl:

<pre>
batctl bw <MAC ADDRESS>
</pre>

when the test is over the throughput in *Bytes per second* is returned.
Example:

<pre>
# batctl bw 00:00:00:00:00:01
Bandwidth meter called towards 00:00:00:00:00:01
Test over in 3564 ms.
         sent 70000000 bytes.
Throughput 19640000 Byte/s
</pre>

The test doesn't print any output until it's termination; you can abort an ongoing test with SIGINT (CTRL-C).

h2. PROTOCOL 

The protocol is a connection oriented, "Go-Back-N":http://en.wikipedia.org/wiki/Go-back-N protocol with fixed window and cumulative acknowledgement. Of the two end nodes, one is the sender and the other the receiver; their behaviour is described in the next subsections.

During the test ICMP packets only are exchanged, so two fresh ICMP packet types are defined (BATADV_BW_METER, BATADV_BW_ACK). A node can participate in different tests at the same time, but with different nodes. This means that two or more tests cannot be performed at the same time between the same two nodes.

Between two consecutive experiment runs at least two seconds should be waited, to assure connection is closed before its re-opening.

h3. The sender

The sender maintains, for each ongoing test, the following variables:

* *next_to_send* the next packet in the window that is to be sent
* *window_first* the sequence number (i.e. packet number) of the first packet of the current window, the first un-acknowledged packet;

!window.png!

To begin the test, the sender sends BW_WINDOW_SIZE packets in a burst and starts a timeout, waiting for an ack. An ACK is an ICMP packet of type BATADV_BW_ACK that carries the sequence number of the last received packet *in order* (cumulative acknowledgment), meaning that all the packets up to that sequence number have been received. If the ACK for a packet is not received before the timeout expires, all the unacked packets in the window are re-transmitted. The sender ICMP packet has message type BW_METER.

So BW_WINDOW_SIZE packets are sent, then the a timeout is started:

* "when the timeout expires* the whole window is transmitted again. This means BW_WINDOW_SIZE packets are transmitted, with sequence numbers starting from window_first, the last packet that has been acknowledged;
* *when ack is received* the timer is updated. Update window_first to ack's "sequence number" and send from next_to_send to (window_first + BW_WINDOW_SIZE) new packets (with seqno starting from next_to_send). Every time a packet is sent, next_to_send is increased.

!protocol1.png!

h3. The receiver

To begin the test, the receiver must receive an ICMP packet with msg_type BW_METER and sequence number BATADV_BW_FIRST_SEQ: if another packet is received, the test is not considered started, no ack is sent back and no data structure is allocated on the receiver side. 

If that particular packet is received and no other bandwidth test is ongoing with the same node, the connection is opened.

The receiver basically keeps a single variable, the beginning of the window:

* *window_first* the sequence number of the first packet of the window, the first in order packet expected.

If a BW_METER packet is received on that connection, it's offset is checked: if it belongs to the window, shift window_first and send back an ACK. Otherwise, just send back an ack to avoid protocol deadlock. The receiver also maintains a bitmap to keep track of the packets received not in order. The bitmap is composed of many bits as there are packets in a window. Every time a packet is received, the corresponding bit is set to 1. An ACK with the last *in order* sequence number received is sent back, whether the receiver window has advanced or not.

When a packet that is not full (its full size is different from that of the others) is received *in order* the test is finished. Send a normal ACK back with the sequence number of the short packet, wait a certain amount of time and "declare the test finished" (i.e. free variables and accept new test packets). 
The time to wait should be greater than sender's timeout + RTT: if the last ACK is lost, the sender should re-send all the missing packets of the last window after the timeout expires. If no packet is received in 1 second, the receiver declares the connection closed and aborts the test.

h2. PROBLEMS and FURTHER DEVELOPMENT

Two main protocol limitations lies in the fixed size of the window and in the slow reaction of the timeout.

The window problem depends on the fact that at most a window can be sent every round trip time, as shown in the image above. If the window size is small, this can limit the performances; the window size also affects retransmission, in case a packet is lost, the whole
window is retransmitted.

When a packet is lost, no new ACKs are received: the window is not slit and thus, after having sent all the packets in the window, the protocol is stuck.
This undesiderable situation lasts until the timeout expires. This would suggest a short timeout is better since it avoids a long protocol locking. On the other hand, if the timeout is shorter than RTT, it expires before the ACKs can arrive, leading to many unnecessary retransmissions. Since RTT depends on the network structure, it is safer to have a more conservative timeout.

A possible solution to the first problem could be a dynamic window system similar to that of TCP: every time an ack is received, the window is enlarged
(up to a maximum fixed size) and everytime something bad happens (timeout expires or ``fast retransmit"-like approaches could also be considered) it is reduced.

A dynamic timeout, based on RTT measured while test is performed, could make the protocol more performant even in case of high packet losses. Furthermore something similar to TCP's "fast-retransmit" could also be implemented easily: if three ACKs are received with the same packet number, that probably means the next packet has been lost and it can be resend alone, without the need to resend
the whole window.

Since both the window size and the timeout are statically defined in the current implementation, the protocol performances greatly depends on how their chosen values adapt to the network scenario in which the test is performed.