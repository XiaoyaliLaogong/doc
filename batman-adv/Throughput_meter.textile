h1. *BANDWIDTH METER*

h2. REPOSITORIES

 * http://git.open-mesh.org/?p=montik/batman-adv.git
 * http://git.open-mesh.org/?p=montik/batctl.git

h2. GENERAL DESCRIPTION

The project aims to create a kernel-space tool that measures the throughput between two nodes and avoids problems experienced with user-space tools like iperf and netperf. With those tools main problems are encountered on machines that are low on resources, including routers, since packets must be copied from kernel-space to user-space memory and aligned. On such devices this computational load can slow the device itself, leading to packet losses at the receiver side, thus altering the test result. Two modes are implemented:

* tcp-like: in this mode the behaviour of tcp should be re-created. We should verify if it is possible to use the existing, standard, tcp implementation or if it is needed to develop a tcp-like (simpler...) protocol just for this application.
** Using kernel TCP stack is too complex and the problem of unaligned data remains. Furthemore it requires an IP address for the destination.

* udp-like: one directional, no retransmission, stream of data;
** How to ensure that all data was transmitted
** How do we ensure that the last packet/magic packets were not transmitted out of order
** how does the remote node gets informed that test finished even when *many* packets are dropped

h2. SPECIFICATION

# the protocol will be a "Go-Back-N":http://en.wikipedia.org/wiki/Go-back-N: a fixed window, cumulative acknowledgment when the whole window is received; this is intended as a rough approximation of the TCP behaviour;
# The user specifies how much data the bandwidth meter is intended to send in the session; once the transmission is completed (i.e. all the data is received by the sender) the transmission time is reported. _Further details on time computation to be added_; It should allow:
## Possibility to specify if the node is sender or receiver (data flow direction);
## Possibility to add others operation modes later (e.g. "UDP" mode);
## Integrated in the batman ICMP protocol; 
## The test is initiated through batctl. The user specifies at least the destination, the amount of data to be sent, if it is sender or receiver.

h2. PROTOCOL 

Two new bat-ICMP packet type, BW_METER and BW_ACK, are defined.

In order to provide an easier protocol to implement, Go-Back-N is used, with a static window. The window is made of WIN_PACKETS packets (this could be specified by the user or fixed). T

h3. The sender

The sender maintains, for each test ongoing, the following variables:
# to_send: total amount of data to send;
# first_sent: sequence number (i.e. offset) of the first packet of the current window
# window_size

It sends WIN_PACKETS packets in a burst and starts a timeout, then waits for an ack, that is an ICMP packet with number BW_ACK. The ack should carry the seqence number first_sent+window_size. If the ack is not received before the timeout expires, all the n packet are re-transmitted. Notice that there is no buffer, just the three variables that "emulates" it. The sender ICMP packet has type BW_METER, a 32 bit offset and a 32 bit window size.

So WIN_PACKETS are sent, then the timeout is start:

* if the corresponding ack is received, first_sent is set to first_sent+window_size and the next WIN_PACKETS packets are sent;

* if the timeout expires, first_sent is not increased, so the same packets are sent again;

* When first_sent equals to_send, the test is over.

h3. The receiver

The receiver must receive the packet with offset 1 first. If no other bandwidth test is ongoing with the same node, it initiates the following variables for that connection:

# window_size
# first_received: the offset of the first packet of the window
# to_be_received: equals window_size

If a BW_METER packet is received on that connection, it's offset is checked:

# if it is first_received <= offset < first_received+window_size, the packet belongs to the current window. Then to_be_received is decreased by the packet length. If it equals zero a new window is initiated:
## first_received += window_size;
## to_be_received = window_size;
## send the ack with offset first_received;

# if packet offset < first_received, resend ack

# if packet offset > first_received+window_size ???

When a packet is received that is not full: i.e. its full size is different from that of the others, the test is finished. Send a normal ack with the offset of the "short packet" + "short packet len", wait a certain amount of time and "declare the test finished" (i.e. free variables and accept new test packets).

So, the ACK packet is an ICMP packet with type BW_ACK and a 32 bit offset.


h2. TODO

h3. Currently doing

* define and initialize a data structure bw_meter_vars for variables used. The structure should be sender-dependant; [Adding it to bat_priv by now]

* send all the window;

* timeout;

h3. Future tasks

* do the receiver ???

h3. Done

* define the BW_METER icmp packet header in packet.h 

@
/* icmp_packet_bw must start with all fields from imcp_packet
 * as this is assumed by code that handles ICMP packets
 */
struct icmp_packet_bw {
        struct batman_header header;
        uint8_t  msg_type; /* see ICMP message types above */
        uint8_t  dst[ETH_ALEN];
        uint8_t  orig[ETH_ALEN];
        __be16   seqno;
        uint8_t  uid;
        uint8_t  reserved;
        uint32_t offset;
        uint32_t wsize;
} __packed;
@

* upon batcl bw invocation a single BW_METER is sent to the destination. Destination by now only logs the packet is received; tested ok with vm;

* define and implement user-space interface (through batctl) [options still to be added]: 
** created files bw_meter.c in batman-adv and in batctl
if batctl bw is invoked from the command line, a function in kernel space get called, in a similar fashion as for ping (but the packet will be generated in kernel space)

* define the protocol, based on Go-Back-N

* set up virtual machines for testbed: using two virtual machine with Debian and kernel 3.2.12 to test the modifications introduced in order to call the bandwidth meter through batctl; the two machines are attached to two tun interfaces bridged together.

h2. Documentation

 * "data alignment in the kernel":http://www.mjmwired.net/kernel/Documentation/unaligned-memory-access.txt

 * "skb":http://vger.kernel.org/~davem/skb.html

 * TFTP ??