h1. *BANDWIDTH METER*

h2. REPOSITORIES

 * http://git.open-mesh.org/?p=montik/batman-adv.git
 * http://git.open-mesh.org/?p=montik/batctl.git

h2. GENERAL DESCRIPTION (initial idea)

The project aims to create a kernel-space tool that measures the throughput between two nodes and avoids problems experienced with user-space tools like iperf and netperf. With those tools main problems are encountered on machines that are low on resources, including routers, since packets must be copied from kernel-space to user-space memory and aligned. On such devices this computational load can slow the device itself, leading to packet losses at the receiver side, thus altering the test result. Two modes are implemented:

* udp-like: one directional, no retransmission, stream of data;
** How to ensure that all data was transmitted
** How do we ensure that the last packet/magic packets were not transmitted out of order
** how does the remote node gets informed that test finished even when *many* packets are dropped

* tcp-like: in this mode the behaviour of tcp should be re-created. We should verify if it is possible to use the existing, standard, tcp implementation or if it is needed to develop a tcp-like (simpler...) protocol just for this application.
** Using kernel TCP stack is too complex and the problem of unaligned data remains. Furthemore it requires an IP address for the destination.


h2. FIRST SPECIFICATION

May 2, me, Ordex, Simon and Marek agreed on the following:

# the "TCP" version will be developed first;
# the protocol will be a "Go-Back-N":http://en.wikipedia.org/wiki/Go-back-N: so sliding window, cumulative acknowledgment. _Further protocol definition_ soon; this is intended as a rough approximation of TCP behaviour;
# The user specifies how much data the bandwidth meter is intended to send in the session; once the transmission is completed (i.e. all the data is received by the sender) the transmission time is reported. _Further details on protocol header formats, time computation_ soon; It should allow:
## Possibility to specify if the node is sender or receiver (data flow direction);
## Possibility to add others operation modes later (e.g. "UDP" mode);
## Integrated in the batman ICMP protocol; 


h2. PROTOCOL 

h3. Header

Since the protocol is taken from TCP, I started from TCP header ("RFC793":http://www.ietf.org/rfc/rfc793.txt) and removed some unecessary feature, namely push, urgent and port multiplexing.

<pre>
   0                   1                   2                   3   
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |  
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |  
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Window Size                          |A|R|S|F|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Options            |             Checksum          |  
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

Header fields have the same functions as in TCP. Also the flags A, R, S, F:
* ACK: means an ack is carryed, so Acknowledgment Number is valid
* RST: resets the connection (in case of errors or unexpected packages)
* SYN: starts the connection (three way handshake)
* FIN: Gracefully ends the connection

I have to decide if and how to implement:
* slow start
* congestion avoidance 

* fast retransmit
* fast recovery

h2. TODO

* define the protocol, based on Go-Back-N

* define packet header