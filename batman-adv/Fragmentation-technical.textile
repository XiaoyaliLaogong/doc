h1. Fragmentation

This page describes the current status of the GSOC12 project to improve the fragmentation functionality to support more than just unicast packets.

h2. "New" Implementation

The initial requirements to the new fragmentation framework are:
* One packet can be transmitted as two or more fragments.
* Fragments are encapsulated with a "fragment header".
* Nodes announce through tvlv if they are able to assemble fragments.
* Fragmentation of broadcasts might be supported in the future.
* Maximum fragment size is runtime configurable to support user tuning.
* Fragments are assembled as soon as the outgoing interface supports the assembled size - forwarded otherwise.

The following questions are open:
* Should the contained packet type be visible in the fragment header?
* How do we select supported packet types (whitelist, blacklist or some kind of passed flag)?
* Should we make a separate header for the first fragment?

Initial header structure:
<pre>
struct frag_packet {
	struct batman_header header;
	uint8_t frag_type; /* Packet type of the contained packet */
	uint8_t frag_id;   /* Almost unique id for the set of fragments */
	uint8_t frag_cnt;  /* Number of fragments in this set */
	uint8_t frag_seq;  /* Sequence number of this fragment */
	uint8_t flags;
} __packed;
</pre>

h2. "Old" Implementation

Unicast packets are transmitted by calling batadv_unicast_generic_send_skb() in unicast.c. Here the size of the packet is checked and the packet is fragmented if needed:
<pre>
	/* fragmentation mechanism only works for UNICAST (now) */
	if (packet_type == BAT_UNICAST &&
	    atomic_read(&bat_priv->fragmentation) &&
	    data_len + sizeof(*unicast_packet) >
				neigh_node->if_incoming->net_dev->mtu) {
		/* send frag skb decreases ttl */
		unicast_packet->header.ttl++;
		ret = batadv_frag_send_skb(skb, bat_priv,
					   neigh_node->if_incoming,
					   neigh_node->addr);
		goto out;
	}
</pre>

The fragmentation is carried out in batadv_frag_send_skb() in unicast.c. This function "simply" allocates another skb, copies half the packet into this, and sends the two packets.

The fragmented packet is constructed with a "unicast-like" header, plus some additional fields:
<pre>
struct unicast_packet {
	struct batman_header header;
	uint8_t  ttvn; /* destination translation table version number */
	uint8_t  dest[ETH_ALEN];
} __packed;

struct unicast_frag_packet {
	struct batman_header header;
	uint8_t  ttvn; /* destination translation table version number */
	uint8_t  dest[ETH_ALEN];
	uint8_t  flags;
	uint8_t  align;
	uint8_t  orig[ETH_ALEN];
	__be16   seqno;
} __packed;
</pre>

When fragmented packets are received, a "per-orig-buffer" is searched for a matching fragment. If one is found, the two fragments are assembled and treated like a regular unicast packet. If no matching fragment is found, the received fragment is buffered for a later merge.