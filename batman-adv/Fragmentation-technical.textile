h1. Fragmentation

This page describes the current status of the GSOC12 project to improve the fragmentation functionality to support more than just unicast packets.

h2. "New" Implementation

h3. The initial requirements to the new fragmentation framework are:

* One packet can be transmitted as two or more fragments.
* Fragments are encapsulated with a "fragment header".
* Nodes announce through tvlv if they are able to assemble fragments.
* Fragmentation of broadcasts might be supported in the future.
* Maximum fragment size is runtime configurable to support user tuning.
* Fragments are assembled as soon as the outgoing interface supports the assembled size - forwarded otherwise.
* The type of the contained packet is not stored in the fragment header, as needing functions should peek into the payload.
* All packets except broadcast/multicast are fragmented (for now).
* A small hash table with 8 entries is used as fragment buffer.
* No compile time option is provided, as networks might break if only some nodes supports fragmentation.

h3. To Do List

* -Limit number of packets in a list of fragments (max 16)-
* -Add final destination to fragment_packet-
* -Check if the packet should be forwarded without merging-
* -Add comments before I forget the tricks!-
* -Set and use the ttvn field-
* Test with packet loss and reordering
* -Clean up timed out packets-
* Add locking to fragment buffers
* -Handle "echo packets"-
* Delete existing fragmentation code. (And decide where to put batadv_unicast_send_skb() )
* -Change batadv_send_skb_packet() to find the next hop-
* -Use hton() and ntoh()-
* -Add kernel doc comments.-
* Decouple the "complete" list of fragments before merging.

h3. Open Questions

* Do we want to and how do we avoid "refragmentation"  at later hops?
   Scenario: "A(mtu: 1500) -> B(mtu: 1550) -> C(mtu: 1500) -> D(mtu: 1550)". In this case, A would fragment the packet and send it to B, who would merge it and send it to C, who would fragment it again. Is it feasible to not merge the packets at B and, if so, how should we tell B not to merge the packet?
* How do we integrate fragments with translation tables?
   Scenario: Orig A fragments a unicast packet from a Client A and sends it towards Client B connected to Orig B. While the fragments travel the relays in the network, Client B roams to Orig C. Relays cannot redirect fragments to Orig C, because they don't know that the fragments carry a unicast packet to Client B.
* How do we handle very-very-big-tt-tables™?
  Scenario: When an originator serves a very-very-big-LAN™, the full table (and inital changeset) could be bigger than one MTU. The simple solution is to just create a big skb and let the fragmentation code chop it up. But if the skb is bigger than 16*(~)mtu, the fragmentation code will simply discard the packet.

h3. Header structure:

<pre>
struct batadv_frag_packet {
	struct   batadv_header header;
	uint8_t  ttvn; /* destination translation table version number */
	uint8_t  dest[ETH_ALEN];
	uint8_t  orig[ETH_ALEN];
	uint8_t  flags:4;
	uint8_t  no:4;   /* Sequence number of this fragment */
	uint16_t seqno; /* Almost unique id for the set of fragments */
	uint16_t total_size;
} __packed;
</pre>

h3. Structure / Packet flow

h4. Sending:

# Packet hits batadv_send_skb_packet() and has size > mtu
# Packet is fragmented and transmitted as BAT_FRAG type

h4. Receiving:

# Packet is received as BAT_FRAG and is handed to batadv_recv_frag_packet()
# Packet is buffered in per-orig-buffer until all fragments are received.
# When last packet arrives (list-size == frag_count), packets are assembled and handed to appropriate handler

h4. Cleaning:

# A worker traverses packet lists for each orig and removes fragments after a timeout.

h2. "Old" Implementation

Unicast packets are transmitted by calling batadv_unicast_generic_send_skb() in unicast.c. Here the size of the packet is checked and the packet is fragmented if needed:
<pre>
	/* fragmentation mechanism only works for UNICAST (now) */
	if (packet_type == BAT_UNICAST &&
	    atomic_read(&bat_priv->fragmentation) &&
	    data_len + sizeof(*unicast_packet) >
				neigh_node->if_incoming->net_dev->mtu) {
		/* send frag skb decreases ttl */
		unicast_packet->header.ttl++;
		ret = batadv_frag_send_skb(skb, bat_priv,
					   neigh_node->if_incoming,
					   neigh_node->addr);
		goto out;
	}
</pre>

The fragmentation is carried out in batadv_frag_send_skb() in unicast.c. This function "simply" allocates another skb, copies half the packet into this, and sends the two packets.

The fragmented packet is constructed with a "unicast-like" header, plus some additional fields:
<pre>
struct unicast_packet {
	struct batman_header header;
	uint8_t  ttvn; /* destination translation table version number */
	uint8_t  dest[ETH_ALEN];
} __packed;

struct unicast_frag_packet {
	struct batman_header header;
	uint8_t  ttvn; /* destination translation table version number */
	uint8_t  dest[ETH_ALEN];
	uint8_t  flags;
	uint8_t  align;
	uint8_t  orig[ETH_ALEN];
	__be16   seqno;
} __packed;
</pre>

When fragmented packets are received, a "per-orig-buffer" is searched for a matching fragment. If one is found, the two fragments are assembled and treated like a regular unicast packet. If no matching fragment is found, the received fragment is buffered for a later merge.