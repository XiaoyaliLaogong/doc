h1. Fragmentation

To transport packets through the mesh network, batman-adv prepends its own header to packets entering the mesh. Since clients and other sources of packet don't know about this additional header, packets are often optimized for the usual MTU of 1500 bytes, meaning that the additional header increases the size to e.g. 1528 bytes. To handle this, batman-adv recommends users to increase the MTU of the wireless interface to at least 1528 bytes. However, some drivers/hardware don't support an MTU larger than 1500 bytes, or batman-adv might need to transmit big protocol packets, and for this we need fragmentation.

h2. Protocol Header

The fragment header contains several fields:
* *Batman-adv common header* 
  Compatibility version, packet type, and time-to-live
* *Destination*
   Used to route fragments if it wouldn't make sense to merge them. (E.g. when the merged packet larger than the intermediate MTU and thus would be fragmented again anyways.)
* *Originator*
   Used to group fragments in the buffer. This and the sequence number makes the original packet identifiable.
* *Fragment number*
   Used to sort the fragments before merging them.
* *Sequence number*
   Used to identify the group of fragments.
* *Total size*
   Used to determine whether a fragment should be merged before forwarding and also to determine if all fragments are received.

h2. Creating Fragments

Any type of unicast packet (e.g. @struct unicast_packet@, @struct tt_response@, @struct vis_packet@, etc) can be fragmented.

!tx.png!

The size is checked in @send_skb_to_orig()@ and if larger than the MTU of the selected outgoing interface (selected by [[batman-adv:Multi-link-optimizations-technical|bonding]]) the packet is passed to @frag_send_packet()@. Here, fragments are created and sent from the tail of the original packet, so that the first fragment contains the end of the original packet:

!first_fragment.png!

The first fragment is passed to @send_skb_packet()@ to be transmitted and if the size of the remaining part of the original packet is also larger than the MTU, another fragment is created:

!second_fragment.png!

Now the remaining part is small enough to transmit in one piece, so the fragment header is added and the packet is passed to @send_skb_packet()@:

!third_fragment.png!

These completes the creation of fragments.

h2. Merging Fragments

Fragments are identified by the packet type in the batman-adv common header.

!rx.png!

When receiving a fragment, it is passed to @recv_frag_packet()@ in @routing.c@, where it is either forwarded, buffered, or merged. Merged packets are passed to the primary receive function again and processed by its original handler.

# *Check total size*
  If destination fields contains another originator and the size of the original packet is greater than the MTU, the fragment is forwarded without merging.
# *Buffer fragment*
  The fragment is buffered (in reverse order) in a list of fragments with equal sequence numbers from the same originator.
# *Check for complete fragments*
  If the accumulated size of the received fragments equals the total size given in the fragment header, the list moved out of the buffer and handed to the merge function.
# *Merge fragments*
  The first fragment in the list (which is the last fragment, see item no. 2) is expanded to contain the payload of the rest of the fragments, which are then copied into the first fragment.
# *Handle original packet*
  The merged packet is passed to @batman_skb_recv()@ where it is processed as usual.

h2. Configuration

First of all, fragmentation shouldn't be needed (except for tt-tables, see below). It is a fix for drivers/hardware that is unable to handle MTU's greater than 1528 bytes, it is slow (due to increase is packets), and is fragile to packet loss.

It can be enabled and disabled in the sysfs file:
<pre>
%25 echo 1 > /sys/class/net/bat0/mesh/fragmentation # enable (default)
%25 echo 0 > /sys/class/net/bat0/mesh/fragmentation # disable
</pre>
or by using @batctl@:
<pre>
%25 batctl f 1 # enable
%25 batctl f 0 # disable
</pre>

h2. The TT Issue

To summarize the very-big-local-TT issue:

*Before:*
If the size of the local table exceeds the MTU, we simply truncate the response. This response now leads to a wrong CRC at the receiver of the response, who then issues a new request. Thus loop will repeat until the local table fits the MTU again.

*After:*
When the size of the local table hits the MTU limit (with or without fragmentation), new clients are ignored and packets from ignored clients are dropped. By dropping the packet, we avoid the creation of temporary global clients at the destination originator.
If the MTU is decreased to less than the size of the current local table, the local table is brutally and dictator-wise truncated to fit the new minimum MTU (with or without fragmentation). I have chosen to simply delete the entries immediately as opposed to marking them as pending, because we cannot include them in a response anyways, so there is no point in keeping them. Until the next OGM is emitted with a new TTVN, any full-table responses are sent with temporaily increased ttvn, which causes the receiver to believe the CRC from the new table.

There is one remaining issue for which I cannot see any solution: What to do when an intermediate node has an MTU lower than its two neighbors? If we have "A <-> B <-> C", where A and C have MTU=1550 and B has MTU=1000 bytes, B cannot respond with nor forward very-big-full-tables from A to C. If B receives a full-table-request from C to A, I have chosen to let B forward the request to A, and hope that the response will find another way to C :)

The only perfect solution to the very-big-local-TT issue is a higher layer of fragmentation, but IMHO this requires too much complexity to a too rare situation. (E.g. what are the riscs of packet loss with, say, 128 fragments?)

h2. Future Improvements

* Checking total size of original packet uses the MTU of the incoming interface. In case of bonding, the fragment might be transmitted on another interface.
* The fragment buffer in @struct orig_node@ should only be allocated on demand, as most networks doesn't need fragmentation.