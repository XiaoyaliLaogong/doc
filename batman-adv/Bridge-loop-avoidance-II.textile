h1. Bridge loop avoidance II

This page contains a concept in progress, it is not implemented yet, but feel free to discuss it.

h2. Situation

!situation.dia.png!:http://www.open-mesh.org/attachments/100/situation.dia.png

This is the example we will use to discuss the concept: multiple mesh nodes (called backbone gateways throughout the text) are connected to a big, single LAN (the backbone) as well as mesh nodes which are not connected to the backbone. LAN connections are drawn with solid lines, mesh connections with dotted lines. You can see an internet gateway connected through the LAN (this could be any other network device as well) at the top and a client (e.g. your laptop) connected/bridged through a mesh node in the bottom.


h2. Definitions:

 * backbone gateway: A mesh node which is conncted to both - a mesh network and a LAN.
 * client: A non-mesh network participant which is sending data via the mesh. The client is always identified by the source MAC address of the payload Ethernet header.

h2. Goals:

 * The bridge loop avoidance should be able to scale to hundreds of gateways connected to the same LAN.
 * Communication between the mesh nodes and the LAN should be via the best backbone gateway.
 * Minimize broadcast traffic in the LAN.
 * Roaming should still be possible.

h2. Key Concepts:

h3. Claiming clients:

Only one backbone gateway (out of possibly many gateways) should forward traffic from a non-mesh client (coming via the mesh) to the LAN. Every backbone gateway announces the mac addresses of the non-mesh clients it feels responsible for in the form of "claim frames" on the soft-interface bat0. Each backbone gateway will save a claim list of other backbone gateways. By doing this, it can:

 * see which clients are already tracked (claimed)
 * see which other backbone gateways exist in the LAN

Note that backbone gateways may overwrite a claim of another backbone gateway by simply claiming the same client. In this case, the newest claim wins, and local databases are updated accordingly.

Backbone gateways can also "unclaim" their own clients. After doing this, the client is not claimed anymore for this LAN.

h2. Details and Cases:

The concept will be explained by discussing the different cases: unicast and broadcast frames, both for the LAN->mesh and mesh->LAN case. Loop cases are considered too: LAN->mesh->LAN
and mesh->LAN->mesh. Furthermore, roaming is discussed when a client changes from the LAN to another mesh node and back.

h3. Broadcast, mesh->LAN:

!mesh_LAN.dia.png!
If the originator of the broadcast is not known (not in the originator table), drop it.

If the originator of the broadcast is another backbone gateway from the same LAN, drop it.

If a backbone gateway has already claimed the client, only the resposible backbone gateway will deliver the frame to the backbone/LAN. Other backbone gateways will discard the packet.

If no backbone gateway has claimed the client, the first client receiving the broadcast will claim it in the backbone by sending a claim frame, and send the actual broadcast frame.

h3. Unicast, mesh->LAN:

!mesh_LAN_unicast.dia.png!

If the client is not claimed by the backbone gateway receiving the unicast, a claim packet is sent out first. This backbone gateway is now the (new) responsible backbone gateway for this client.

Then, the unicast packet is delivered to the soft interface.

h3. Broadcast, LAN->mesh:

!LAN_mesh.dia.png!

If a claim for the mesh-client exists:

 * all not responsible backbone gateways should discard the frame - this might be a loop. 
 * if the responsible backbone gateway (which claimed this client) also receives the packet, "unclaim" this client by sending an according un-claim packet, and forward the packet into the mesh. This should only happen in the roaming case, but not in normal situations.

If the client is not claimed, all backbone gateways will send the broadcast into the mesh. The mesh nodes will avoid duplicates by using the duplicate lists (see optimizations below)

h3. Unicast, LAN->mesh:

!LAN_mesh_unicast .dia.png!

Nothing fancy should happen here, as a switch should do the right thing. If the client is not claimed, the frame is simply sent into the mesh.

However, when using hubs (or broken switches), also unicast packets might loop. Therefore, if the client (source of the Ethernet frame) is claimed by any backbone gateway, drop it.

h3. mesh->LAN->mesh loop:

!mesh_LAN_mesh.dia.png!

A broadcast frame is only sent to LAN by the (yet to be) responsible backbone gateway. Back from the LAN to the mesh, all not responsible backbone gateways will drop the frame. The responsible backbone gateway should not receive it on normal switched networks.

To avoid loops for hubs, unicast packets are dropped from LAN to mesh if the client is claimed.

h3. LAN->mesh->LAN loop:

!LAN_mesh_LAN.dia.png!

Although a broadcast frame is sent into the mesh, it won't loop back into the LAN as a backbone gateway will drop it if was sent from another backbone gateway (from the same LAN).

h3. LAN->mesh Roaming:

!Test_roaming_LAN_mesh.dia.png!

This is the easy case: Sooner or later, a claim will be added for the roamed client.

h3. mesh->LAN Roaming:

!Test_roaming_mesh_LAN.dia.png!

We assume that the client was already claimed by a backbone gateway before, otherwise there is nothing to consider.

When a broadcast frame is sent, the responsible backbone gateway can detect the roam and will unclaim the client. This first broadcast will only be broadcasted by the (previously) responsible backbone gateway into the mesh, later broadcasts will be sent by all backbone gateways again.

h3. Gateway selection:

!gateway_selection.dia.png!

All gateways announce the clients within their LAN and ignore roaming messages from other gateways on the same LAN.

Other non-gateway meshnodes may select their best gateway to the LAN based on the TQ value. 

h3. Claim frames

!claimtypes.dia.png!

All claim operations are sent using "special" gratious ARP frames. 4 types are used which are illustrated above:

 * CLAIM frames are used to tell others that a backbone gateway feels responsible for a client now
 * UNCLAIM frames are sent when a backbone gateway does not feel responsible anymore
 * ANNOUNCE frames are sent regularly to find other backbone gateways and provides the CRC of its local table
 * REQUEST frames are used to ask for a full table update when the information is out of sync (i.e. the announced crc does not match with the local crc)

the claim type is announced within the 4th byte of the Target HW address. Each claim frame is discussed in detail further.

+Note:+ Although this is a misuse of ARP packets, the "normal" ARP process should not be disturbed as the IP addresses
(0.0.0.0) should not be in any sane ARP table. As far as I understand, a gratious ARP should only be considered if the 
IP address is already in an ARP table [2].

[1] http://tools.ietf.org/html/rfc826
[2] http://tools.ietf.org/html/rfc2002#section-4.6

+CLAIM frames+

A CLAIM frame is sent when a new client is added to the local table and the backbone gateway wants to be responsible now.

Backbone gateways which receive a CLAIM frame (and accept the backbone gateway) must add the claim in their tables, replacing older claims if they are present (even their own).

+UNCLAIM frames+

An UNCLAIM frame is sent when the backbone gateway is not responsible anymore, e.g. due to detected roaming into the backbone or a timeout

Backbone gateways which receive an UNCLAIM frame (and accept the backbone gateway) must remove the the claim from their tables.

+ANNOUNCE frames+

The periodic ANNOUNCE frames (default: every 10 seconds) by the backbone gateways serve the following purposes:

 * backbone gateways learn about the existence of other backbone gateways (this is important for new gateways)
 * when no ANNOUNCE frames are received anymore, we can assume that this backbone gateway is no longer serving the LAN and can remove its claims
 * it contains a checksum (the last 2 bytes YY:YY within the Sender HW address) which other backbone gateways can use to check their table consistency. If a table is not consistent, a backbone gateway can ask for the full claim table via the REQUEST frame.

Note: the SRC HW address is a "locally administered address" group address which should not be used by any NIC or protocol, but is not registered with the IEEE

+REQUEST frame+

A REQUEST frame is sent by a backbone gateway who just received an ANNOUNCE frames and discovers that the CRC is out of sync.

It then sends a REQUEST frame to the backbone gateway it just received the ANNOUNCE frame from, and deletes all claims it knows from this backbone gateway.

The asked backbone gateway will send all of its local CLAIM frames again, and send another ANNOUNCE frame afterwards.

The requesting backbone gateway will add all claims it receives through the CLAIM frames, and can check the CRC another time once it receives the final ANNOUNCE frame.
(If the CRC is still wrong, the process will start again)

While a request is in flight, the requesting backbone gateway will close down its soft interface for broadcast to avoid loops in this period.

+group forming+

Within the "Target HW address", the last 2 bytes XX:XX are used for as a local group identifier.

After starting batman, these bytes are initialized with the CRC16 checksum of the local mac address. Once it receives a claim frame from another backbone gateway which is also known through the mesh, the own group identifier is copied from this other backbone gateway when it is bigger than the own one. Due to this mechanism, after a short period all mesh nodes who are participating in the same mesh share the same group id.

Generally, claim frames are only accepted if they are on the same group (e.g. participating on the same mesh). This helps for some network scenarios, e.g. when multiple different meshes are connected to one shared LAN (see two meshes test setup below).

h2. Discussion:

h3. Features:

 * no single "super" gateway => should scale better
 * the only additional BATMAN LAN packets are claim packets, which are only sent for new claims
 * no BATMAN packets on the LAN
 * broadcasts are sent from all the gateways into the mesh
 * nodes can select gateways, and change among them (gateways will automatically re-claiming)
 * should not loop ;)

h3. Limitations:

 * other things I might have missed ...

h2. Further Optimizations

h3. Broadcasting by all backbone gateways

Instead of letting only one backbone gateway emit the packets to the mesh, all backbone gateways may send them instead. In this case, we have to make sure that the duplicates are recognized and ignored to deliver the broadcast packets only once to the users.

To do this, we use a "mesh duplicate list": This list is kept for every backbone gateway mesh node which is connected to a LAN with multiple backbone gateways. It checks broadcast packets which are sent from the LAN into the mesh through multiple backbone gateways (and thus multiple times).

If the client is not claimed by any backbone gateway, every backbone gateway shall forward the packet into the mesh. This will lead to duplicates of the broadcast with different meta information (different originators, different sequence numbers). To avoid duplicates within the mesh, every mesh node will use the "mesh duplicate list":

 * after the (old) seqno window check: match the frame to the "mesh duplicate list" of other backbone gateways to see if another backbone gateway from the same LAN has sent a broadcast with the same payload checksum.
 * if true, drop the packet. Otherwise, add the checksum to the entries and re-forward it.

(Note that it might be neccesary to connect the checksums to sequence numbers to allow intentionally sent duplicate payload broadcasts)

h2. Test Cases

h3. Roaming from backbone to mesh

!Test_roaming_LAN_mesh.dia.png!

The client is connected to the backbone first and then roams to a mesh node which is not connected to the backbone.

Ping the internet gateway or a mesh node continuously and see if the connection is recovered.

h3. Roaming from mesh to backbone 

!Test_roaming_mesh_LAN.dia.png!

The client is connected to a meshnode first and then roams the backbone.

Ping the internet gateway or a mesh node continuously and see if the connection is recovered.

h3. A client switches its gateway (due to loss of link/better TQ)

!Test_gateway_selection.dia.png!

Continuously ping the internet gateway from the client, and change the quality of the currently selected node (e.g. adding packet loss).

h3. Limited Horizon tests

!Test_limited_horizon.dia.png!

In this test, the first node A can't reach the last one C due to a limited horizon (the OGMs of A don't reach the OGMs of C and vice versa).

 * Test 1: Client 1 and Client 2 should be able to ping the internet gateway. There are are no bridge loops.
 * Test 2: Client 1 and Client 2 should be able to ping each other.

+note+: Test 2 can only be performed when the batman interface (or one of its VLANs) is used as a batman hard interface. The support for this requires are separate patch.

h3. VLAN support

The clients are connected to local VLANs which are used on top of BATMAN. All claim frames should then have a VLAN tag.

h3. Two LANs connected by one mesh

!Test_2xLAN.dia.png!

Two LANs are connected by one mesh. The backbone gateways of each LAN should find each other and claim only packets from each LAN.
Every node should be able to reach every other node.

h3. Two meshes connected by one LAN

!Test_2xmesh.dia.png!

Two meshes are connected to one LAN. The backbone gateways of each mesh should find themselves and share their claims, but should disregard claims for backbone gateways they are not part of (only possible with the backbone gateway grouping optimization)
Every node should be able to reach every other node.

+note:+ this patch requires the group forming patch to be included.

h2. Open Implementation issues

 * update README and sysfs description
 * add support for soft interface OGM propagation
 * test all test cases (so far, only basic tests and 2x mesh, 2x LAN)
 * send to ml, add review points

h2. Further ideas 

h3. from discussion on 2011-06-08:

 * What to do if a gateway fails? how do we timeout it? - we could change the concept to work like the new TT: regular updates of changes (with a sequence number), only send changes, and request full update if required. The regular update would allow us to timeout gateways if they are no longer there/connected.
 * Not included in the concept is how we handle LAN-interconnected, separate mesh clouds. The gateways of the different mesh clouds would claim clients, which would prevent traffic going from mesh 1 to mesh 2. This could be solved by verifying that a gateway is not only accessible via LAN, but also via mesh (looking into the originator table). If they are not in our mesh, we ignore the claims.
 * Instead of using the "mesh duplicate list", we could also try to synchronize the broadcast sequence numbers of the gateways, so that broadcasts are always sent with the same originator address + sequence number, appearing as the same broadcast. There may be a lot of side effects to consider (packet loss, racing packets, etc ...)
 * some pictures to illustrate the concept would be nice :)

h3. discussion 2011-09-30:

 * it might be sufficient to send broadcast from LAN to mesh from a single gateway and add the broadcast duplicate check later as extension/optimization
 * claims should be sent periodically (every 10 seconds or every 30 seconds) so that other/new gateways get to know about the existence of other gateways on the LAN
 * We should be able to configure:
 ** claim period/resend period
 ** claim backoff timer: this should be very small for LANs (default) and rather high on some high latency backhaul networks (e.g. VPN)
 * the TT code must be enhanced to decide the best gateway based on the TQ value
 * Claim packets should be "standard" packets (not special batman ethertypes) so that paranoid firewalls won't drop them. Using gratious arps may be an idea. 
 ** communication should stay in the mesh as much as possible

h3. Agenda/Comments for next discussion

Please add any comments for the next discussion here:
